@using LPEditorApp.Models
@using System.Linq

<div class="field list-field">
    <label>@Title</label>
    @for (var i = 0; i < Items.Count; i++)
    {
        var item = Items[i];
        <div class="list-block" @key="item.Id">
            <div class="list-row">
                <input class="text" placeholder="テキスト" @bind-value="item.Text" @bind-value:event="oninput" @bind-value:after="NotifyChanged" />
                @if (FontSizeOptions.Length > 0)
                {
                    <select class="text" @onchange="e => OnFontSizeChanged(item, e)">
                        <option value="">サイズ</option>
                        @foreach (var size in FontSizeOptions)
                        {
                            <option value="@size" selected="@(item.FontSize == size)">@size px</option>
                        }
                    </select>
                }
                <input type="color" class="text" value="@GetColorValue(item.Color)" @onchange="e => OnColorChanged(item, e)" title="文字色" />
                @if (AllowDelete)
                {
                    <button type="button" class="btn small" @onclick="() => RemoveLineById(item.Id)" disabled="@(Items.Count <= 1)">削除</button>
                }
            </div>
        </div>
    }
    <button type="button" class="btn small" @onclick="AddLine">行追加</button>
</div>

@code {
    [Parameter] public string Title { get; set; } = string.Empty;
    [Parameter] public List<StyledTextItem> Items { get; set; } = new();
    [Parameter] public bool AllowDelete { get; set; } = true;
    [Parameter] public bool AllowEmpty { get; set; } = false;
    [Parameter] public EventCallback OnChanged { get; set; }
    [Parameter] public string DefaultAlign { get; set; } = "center";
    [Parameter] public int[] FontSizeOptions { get; set; } = Array.Empty<int>();
    [Parameter] public FontFamilyOption[] FontFamilyOptions { get; set; } = Array.Empty<FontFamilyOption>();
    [Parameter] public Func<string?, string> GetColorValue { get; set; } = _ => "#d32f2f";

    protected override void OnParametersSet()
    {
        Items ??= new List<StyledTextItem>();
        EnsureDefaults();
        EnsureIds();
    }

    private void EnsureDefaults()
    {
        if (!AllowEmpty && Items.Count == 0)
        {
            Items.Add(new StyledTextItem { Align = DefaultAlign, Visible = true, Id = Guid.NewGuid() });
        }
    }

    private void EnsureIds()
    {
        foreach (var item in Items)
        {
            if (item.Id == Guid.Empty)
            {
                item.Id = Guid.NewGuid();
            }
        }
    }

    private async Task AddLine()
    {
        Items.Add(new StyledTextItem { Align = DefaultAlign, Visible = true, Id = Guid.NewGuid() });
        await OnChanged.InvokeAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveLineById(Guid id)
    {
        if (!AllowEmpty && Items.Count <= 1)
        {
            return;
        }

        var target = Items.FirstOrDefault(x => x.Id == id);
        if (target is null)
        {
            return;
        }

        Items.Remove(target);
        await OnChanged.InvokeAsync();
        await InvokeAsync(StateHasChanged);
    }

    private void NotifyChanged()
    {
        _ = OnChanged.InvokeAsync();
    }

    private void OnFontSizeChanged(StyledTextItem item, ChangeEventArgs e)
    {
        var value = e?.Value?.ToString();
        if (int.TryParse(value, out var size))
        {
            item.FontSize = size;
        }
        else
        {
            item.FontSize = null;
        }

        _ = OnChanged.InvokeAsync();
    }

    private void OnColorChanged(StyledTextItem item, ChangeEventArgs e)
    {
        var value = e?.Value?.ToString();
        item.Color = string.IsNullOrWhiteSpace(value) ? null : value;
        _ = OnChanged.InvokeAsync();
    }
}
