@page "/"
@implements IAsyncDisposable
@using System.Text.Json
@using System.Text.RegularExpressions
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using LPEditorApp.Models
@using LPEditorApp.Services
@using ClosedXML.Excel
@inject TemplateService TemplateService
@inject PreviewService PreviewService
@inject ContentPersistService ContentPersistService
@inject ZipExportService ZipExportService
@inject LpImportService LpImportService
@inject ImageService ImageService
@inject BackgroundPresetService BackgroundPresetService
@inject EditorState State
@inject IHighlightService HighlightService
@inject IJSRuntime JS

<PageTitle>LP Editor</PageTitle>

<div class="lp-editor" id="lpEditorRoot">
	<div class="editor-pane" id="editorPane">
		<h2>LPエディタ</h2>
		<div class="tab-bar">
			<button class="btn @(ActiveTab == "basic" ? "primary" : "")" type="button" @onclick='() => SetTab("basic")'>基本</button>
			<button class="btn @(ActiveTab == "content" ? "primary" : "")" type="button" @onclick='() => SetTab("content")'>入力</button>
			<button class="btn @(ActiveTab == "images" ? "primary" : "")" type="button" @onclick='() => SetTab("images")'>画像</button>
			<button class="btn @(ActiveTab == "design" ? "primary" : "")" type="button" @onclick='() => SetTab("design")'>デザイン/背景</button>
		</div>
		<StepNavigator Steps="GetStepItems()" OnStepSelected="OnStepSelected" />

		@if (State.Error.HasError)
		{
			<div class="error-box">
				<strong>@State.Error.ErrorTitle</strong>
				<div>@State.Error.ErrorMessage</div>
			</div>
		}

		@if (ActiveTab == "basic")
		{
			<div class="tab-content">
				<section class="panel">
					<div class="sub-header">
						<strong>テンプレート情報</strong>
						<button type="button" class="accordion-toggle @(IsSectionOpen("basic-template-info") ? "is-open" : "")" @onclick='() => ToggleSection("basic-template-info")'>@(IsSectionOpen("basic-template-info") ? "閉じる" : "開く")</button>
					</div>
					@if (IsSectionOpen("basic-template-info"))
					{
						<div class="field">
							<label>テンプレート名</label>
							<div class="text">@(!string.IsNullOrWhiteSpace(State.TemplateName) ? State.TemplateName : "未読み込み")</div>
						</div>
						<div class="field">
							<label>テンプレートID</label>
							<div class="text">@(State.Template?.CurrentContent.TemplateId ?? "-")</div>
						</div>
						<div class="field">
							<label>ファイル数</label>
							<div class="text">@(State.Template?.Files.Count.ToString() ?? "-")</div>
						</div>
						<div class="field">
							<label>読み込み日時</label>
							<div class="text">@(State.TemplateLoadedAt?.ToString("yyyy/MM/dd HH:mm") ?? "-")</div>
						</div>
					}
				</section>

				<section class="panel">
					<div class="sub-header">
						<strong>テンプレート</strong>
						<button type="button" class="accordion-toggle @(IsSectionOpen("basic-template") ? "is-open" : "")" @onclick='() => ToggleSection("basic-template")'>@(IsSectionOpen("basic-template") ? "閉じる" : "開く")</button>
					</div>
					@if (IsSectionOpen("basic-template"))
					{
						<div class="field">
							<label>テンプレートZIP</label>
							<InputFile OnChange="OnTemplateZipSelected" accept=".zip" />
						</div>
						<div class="field">
							<label>content.json 読込</label>
							<InputFile OnChange="OnContentJsonSelected" accept=".json" />
						</div>
					}
				</section>

				<section class="panel" data-step="import">
					<div class="sub-header">
						<strong>LP取り込み</strong>
						<button type="button" class="accordion-toggle @(IsSectionOpen("basic-import") ? "is-open" : "")" @onclick='() => ToggleSection("basic-import")'>@(IsSectionOpen("basic-import") ? "閉じる" : "開く")</button>
					</div>
					@if (IsSectionOpen("basic-import"))
					{
						<div class="field">
							<label>LP ZIP</label>
							<InputFile OnChange="OnImportZipSelected" accept=".zip" />
						</div>
						@if (ImportSession is not null)
						{
							<div class="field">
								<label>エントリHTML</label>
								<InputSelect class="text" @bind-Value="ImportEntryHtmlPath">
									@foreach (var entry in ImportSession.HtmlEntries)
									{
										<option value="@entry">@entry</option>
									}
								</InputSelect>
							</div>
							<div class="actions">
								<button class="btn primary" type="button" @onclick="AnalyzeImportAsync" disabled="@(ImportSession is null || ImportSession.HtmlEntries.Count == 0)">解析開始</button>
							</div>
							<div class="import-status">ステータス: @(string.IsNullOrWhiteSpace(ImportStage) ? "待機中" : ImportStage)</div>
						}
						@if (IsImporting)
						{
							<div class="import-progress">@ImportStage</div>
						}
						@if (ImportProject?.IsReady == true)
						{
							<div class="import-dashboard">
								<div class="import-stat">Editable: テキスト @ImportProject.Stats.EditableTextCount / 画像 @ImportProject.Stats.EditableImageCount / リンク @ImportProject.Stats.EditableLinkCount</div>
								<div class="import-stat">Frozen: セクション @ImportProject.Stats.FrozenSectionCount / ブロック @ImportProject.Stats.FrozenBlockCount</div>
								@if (ImportProject.Stats.FrozenReasonSamples.Count > 0)
								{
									<div class="import-note">固定理由: @string.Join(" / ", ImportProject.Stats.FrozenReasonSamples.Take(3))</div>
								}
							</div>
							<div class="actions">
								<button class="btn" type="button" @onclick="StartImportEditing">編集開始</button>
							</div>
							@if (ImportProject.MissingAssets.Count > 0)
							{
								<div class="import-warning">未解決アセット: @ImportProject.MissingAssets.Count 件</div>
								<ul class="import-missing-list">
									@foreach (var missing in ImportProject.MissingAssets.Take(5))
									{
										<li>@missing.Detail</li>
									}
								</ul>
							}
						}
					}
				</section>

				<section class="panel">
					<div class="sub-header">
						<strong>出力</strong>
						<button type="button" class="accordion-toggle @(IsSectionOpen("basic-output") ? "is-open" : "")" @onclick='() => ToggleSection("basic-output")'>@(IsSectionOpen("basic-output") ? "閉じる" : "開く")</button>
					</div>
					@if (IsSectionOpen("basic-output"))
					{
						<div class="field">
							<label>出力ZIPパス</label>
							<input class="text" @bind="OutputZipPath" />
						</div>
						<div class="field">
							<label>content.json 保存パス</label>
							<input class="text" @bind="ContentSavePath" />
						</div>
						<div class="actions">
							<button class="btn" type="button" @onclick="OnSaveContent">content.json保存</button>
							<button class="btn primary" type="button" @onclick="OnExportZip">ZIP出力</button>
						</div>
					}
				</section>

				<section class="panel" data-step="check">
					<h3>出力前チェック</h3>
					<SafetyCheckPanel Issues="GetSafetyIssues()" OnFixRequested="OnSafetyFixRequested" />
				</section>
			</div>
		}

		@if (ActiveTab == "images")
		{
			<div class="tab-content">
			@if (State.BackgroundImagePaths.Count > 0)
			{
				<section class="panel">
					<div class="sub-header">
						<strong>背景</strong>
						<button type="button" class="accordion-toggle @(IsSectionOpen("images-background") ? "is-open" : "")" @onclick='() => ToggleSection("images-background")'>@(IsSectionOpen("images-background") ? "閉じる" : "開く")</button>
					</div>
					@if (IsSectionOpen("images-background"))
					{
						@foreach (var path in State.BackgroundImagePaths)
						{
							<div class="image-item @(IsImageDeleted(path) ? "is-deleted" : "")">
								<div class="image-head">
									<div class="image-path">@path</div>
									<div class="image-meta">@GetImageMetaText(path)</div>
								</div>
								<div class="image-row">
									<img class="thumb" src="@GetImagePreviewSrc(path)" alt="@path" />
									<InputFile OnChange="e => OnImageSelected(e, path)" accept="image/*" />
								</div>
								<div class="image-actions">
									@if (IsImageDeleted(path))
									{
										<span class="badge">削除済み</span>
										<button type="button" class="btn small" @onclick="() => RestoreImage(path)">復元</button>
									}
									else
									{
										<button type="button" class="btn small" @onclick="() => DeleteImage(path)">削除</button>
									}
								</div>
							</div>
						}
					}
				</section>
			}

			@if (State.DecoImagePaths.Count > 0)
			{
				<section class="panel">
					<div class="sub-header">
						<strong>装飾</strong>
						<button type="button" class="accordion-toggle @(IsSectionOpen("images-deco") ? "is-open" : "")" @onclick='() => ToggleSection("images-deco")'>@(IsSectionOpen("images-deco") ? "閉じる" : "開く")</button>
					</div>
					@if (IsSectionOpen("images-deco"))
					{
						@foreach (var path in State.DecoImagePaths)
						{
							<div class="image-item @(IsImageDeleted(path) ? "is-deleted" : "")">
								<div class="image-head">
									<div class="image-path">@path</div>
									<div class="image-meta">@GetImageMetaText(path)</div>
								</div>
								<div class="image-row">
									<img class="thumb" src="@GetImagePreviewSrc(path)" alt="@path" />
									<InputFile OnChange="e => OnImageSelected(e, path)" accept="image/*" />
								</div>
								<div class="image-actions">
									@if (IsImageDeleted(path))
									{
										<span class="badge">削除済み</span>
										<button type="button" class="btn small" @onclick="() => RestoreImage(path)">復元</button>
									}
									else
									{
										<button type="button" class="btn small" @onclick="() => DeleteImage(path)">削除</button>
									}
								</div>
							</div>
						}
					}
				</section>
			}

			@if (State.OtherImagePaths.Count > 0)
			{
				<section class="panel">
					<div class="sub-header">
						<strong>その他</strong>
						<button type="button" class="accordion-toggle @(IsSectionOpen("images-other") ? "is-open" : "")" @onclick='() => ToggleSection("images-other")'>@(IsSectionOpen("images-other") ? "閉じる" : "開く")</button>
					</div>
					@if (IsSectionOpen("images-other"))
					{
						@foreach (var path in State.OtherImagePaths)
						{
							<div class="image-item @(IsImageDeleted(path) ? "is-deleted" : "")">
								<div class="image-head">
									<div class="image-path">@path</div>
									<div class="image-meta">@GetImageMetaText(path)</div>
								</div>
								<div class="image-row">
									<img class="thumb" src="@GetImagePreviewSrc(path)" alt="@path" />
									<InputFile OnChange="e => OnImageSelected(e, path)" accept="image/*" />
								</div>
								<div class="image-actions">
									@if (IsImageDeleted(path))
									{
										<span class="badge">削除済み</span>
										<button type="button" class="btn small" @onclick="() => RestoreImage(path)">復元</button>
									}
									else
									{
										<button type="button" class="btn small" @onclick="() => DeleteImage(path)">削除</button>
									}
								</div>
							</div>
						}
					}
				</section>
			}
			</div>
		}

	@if (ActiveTab == "design")
		{
			<div class="tab-content">
				<section class="panel">
					<div class="sub-header">
						<strong>ページ背景（LP全体）</strong>
						<button type="button" class="accordion-toggle @(IsSectionOpen("background-settings") ? "is-open" : "")" @onclick='() => ToggleSection("background-settings")'>@(IsSectionOpen("background-settings") ? "閉じる" : "開く")</button>
					</div>
					@if (IsSectionOpen("background-settings"))
					{
						<BackgroundSettingEditor Setting="PageBackgroundSetting"
						                       OnChanged="OnPageBackgroundChanged"
						                       PreviewLabel="ページ背景"
						                       PreviewCaption="LP全体に反映されます"
						                       ShowPreset="false" />
						<PageBackgroundPresetEditor Selection="PageBackgroundSetting.Preset"
						                           Presets="BackgroundPresets"
						                           OnChanged="OnPageBackgroundChanged" />
					}
				</section>

				<section class="panel">
					<div class="sub-header">
						<strong>フレーム設定</strong>
						<button type="button" class="accordion-toggle @(IsSectionOpen("card-theme-editor") ? "is-open" : "")" @onclick='() => ToggleSection("card-theme-editor")'>@(IsSectionOpen("card-theme-editor") ? "閉じる" : "開く")</button>
					</div>
					@if (IsSectionOpen("card-theme-editor"))
					{
						<div class="frame-scope-tabs">
							<button type="button" class="tab-btn @(FrameThemeTab == "common" ? "active" : "")" @onclick='() => SetFrameThemeTab("common")'>フレーム（共通）</button>
							<button type="button" class="tab-btn @(FrameThemeTab == "per" ? "active" : "")" @onclick='() => SetFrameThemeTab("per")'>フレーム（個別）</button>
						</div>
						@if (FrameThemeTab == "per")
						{
							<div class="frame-scope-select">
								<label>対象セクション</label>
								<select class="text" @bind="FrameThemeSectionKey" @bind:after="OnFrameThemeSectionChanged">
									@if (DesignSectionOptions.Count == 0)
									{
										<option value="">セクションがありません</option>
									}
									else
									{
										@foreach (var option in DesignSectionOptions)
										{
											<option value="@option.Key">@option.Value</option>
										}
									}
								</select>
							</div>
						}
						<CardThemeEditor
							Style="GetFrameThemeEditorStyle()"
							AnimationStyle="GetFrameAnimationStyle()"
							FontOptions="FontFamilyOptions"
							RecentColors="RecentCardColors"
							OnColorUsed="OnCardColorUsed"
							OnChanged="OnCardThemeChanged"
							OnBandChanged="OnBandThemeChanged"
							OnReset="ResetFrameThemeEditor"
							ScopeLabel="@(FrameThemeTab == "per" ? "フレーム（個別）" : "フレーム（共通）")"
							ScopeNote="@(FrameThemeTab == "per" ? "選択セクションのみ反映" : "全セクションに適用")"
							EnableAnimationTab="@(FrameThemeTab == "per")"
							ShowAnimationScopeToggle="true"
							AnimationScope="@FrameAnimationScope"
							OnAnimationScopeChanged="OnAnimationScopeChanged"
							AnimationPreviewEnabled="@State.Content.AnimationPreviewEnabled"
							OnAnimationPreviewToggled="OnAnimationPreviewToggled" />
					}
				</section>
			</div>
		}

		@if (ActiveTab == "content")
		{
			@if (IsImportMode && ImportProject is not null)
			{
				<div class="tab-content">
					<section class="panel" id="importSectionList">
						<h3>インポートセクション</h3>
						@foreach (var importSection in ImportProject.Sections)
						{
							<div class="import-section-row @(IsSelectedImportSection(importSection) ? "is-active" : "")" @onclick="() => SelectImportSection(importSection.Id)">
								<div class="import-section-title">@importSection.Title</div>
								<span class="import-badge @(importSection.IsFrozen ? "frozen" : "editable")">@(importSection.IsFrozen ? "固定" : "編集可")</span>
								<span class="import-count">T:@importSection.Blocks.Count(b => b.Type == LpImportBlockType.Text) / I:@importSection.Blocks.Count(b => b.Type == LpImportBlockType.Image) / L:@importSection.Blocks.Count(b => b.Type == LpImportBlockType.Link)</span>
							</div>
						}
					</section>

					<section class="panel">
						<h3>編集</h3>
						@if (SelectedImportSection is null)
						{
							<div class="text text-readonly">編集するセクションを選択してください。</div>
						}
						else if (SelectedImportSection.IsFrozen)
						{
							<div class="text text-readonly">このセクションは固定です（編集対象外）。</div>
						}
						else
						{
							<div class="import-block-group">
								<h4>テキスト</h4>
								@foreach (var block in SelectedImportSection.Blocks.Where(b => b.Type == LpImportBlockType.Text))
								{
									<div class="field">
										<label>@block.TagName <span class="import-hint">@block.SelectorHint</span></label>
										<textarea class="text" rows="2" @bind-value="block.Text" @bind-value:event="oninput" @bind-value:after="OnImportInputAsync"></textarea>
													</div>
												}
											</div>

							<div class="import-block-group">
								<h4>画像</h4>
								@foreach (var block in SelectedImportSection.Blocks.Where(b => b.Type == LpImportBlockType.Image))
								{
									<div class="import-image-row">
										<img class="import-thumb" src="@GetImportImagePreview(block)" alt="@block.Alt" />
										<div class="import-image-fields">
											<label>src</label>
											<input class="text" @bind-value="block.Src" @bind-value:event="oninput" @bind-value:after="() => OnImportImageUrlChanged(block)" />
											<label>alt</label>
											<input class="text" @bind-value="block.Alt" @bind-value:event="oninput" @bind-value:after="OnImportInputAsync" />
											<InputFile OnChange="e => OnImportImageFileSelected(e, block)" accept="image/*" />
											@if (block.HasReplaceError)
											{
												<div class="import-warning">差し込みに失敗しました（固定に切替）。</div>
											}
										</div>
									</div>
								}
							</div>

							<div class="import-block-group">
								<h4>リンク</h4>
								@foreach (var block in SelectedImportSection.Blocks.Where(b => b.Type == LpImportBlockType.Link))
								{
									<div class="field">
										<label>テキスト <span class="import-hint">@block.SelectorHint</span></label>
										<input class="text" @bind-value="block.Text" @bind-value:event="oninput" @bind-value:after="OnImportInputAsync" />
										<label>URL</label>
										<input class="text" @bind-value="block.Href" @bind-value:event="oninput" @bind-value:after="OnImportInputAsync" />
										@if (block.HasReplaceError)
										{
											<div class="import-warning">差し込みに失敗しました（固定に切替）。</div>
										}
									</div>
								}
							</div>
						}
					</section>
				</div>
			}
			else
			{
				<EditForm EditContext="EditContext" @oninput="OnAnyInput" @onchange="OnAnyInput">
				<div class="tab-content">
			<section class="panel" data-step="background">
				<div class="sub-header">
					<strong>LP設定</strong>
					<button type="button" class="accordion-toggle @(IsSectionOpen("content-lp-settings") ? "is-open" : "")" @onclick='() => ToggleSection("content-lp-settings")'>@(IsSectionOpen("content-lp-settings") ? "閉じる" : "開く")</button>
				</div>
				@if (IsSectionOpen("content-lp-settings"))
				{
					<div class="field">
						<label>ページタイトル <span class="count">@State.Content.Meta.PageTitle.Length</span></label>
						<input class="text" @bind-value="State.Content.Meta.PageTitle" @bind-value:event="oninput" />
					</div>
					<div class="field">
						<label>キャンペーン内容</label>
						<textarea class="text" rows="2" @bind-value="State.Content.Meta.Description" @bind-value:event="oninput"></textarea>
					</div>
					<div class="field">
						<label>スマホ表示 自動最適化</label>
						<div class="bulk-style">
							<label class="check"><input type="checkbox" @bind="State.Content.CampaignStyle.MobileAutoPadding" @bind:after="OnAnyInputAfter" /> 余白</label>
							<label class="check"><input type="checkbox" @bind="State.Content.CampaignStyle.MobileAutoFont" @bind:after="OnAnyInputAfter" /> フォント</label>
						</div>
					</div>
				}
			</section>

			<section class="panel" data-step="background-section">
				<div class="sub-header">
					<strong>上部ロゴ</strong>
					<button type="button" class="accordion-toggle @(IsSectionOpen("content-header-logo") ? "is-open" : "")" @onclick='() => ToggleSection("content-header-logo")'>@(IsSectionOpen("content-header-logo") ? "閉じる" : "開く")</button>
				</div>
				@if (IsSectionOpen("content-header-logo"))
				{
					<div class="field">
						<label>logoImage</label>
						<InputFile OnChange="e => OnImageSelected(e, State.Content.Header.LogoImage)" accept="image/*" />
					</div>
					<div class="field">
						<label>ロゴ名</label>
						<input class="text" @bind-value="State.Content.Header.LogoAlt" @bind-value:event="oninput" />
					</div>
				}
			</section>

			<section class="panel" data-step="template">
				<div class="sub-header">
					<strong>トップ画像</strong>
					<button type="button" class="accordion-toggle @(IsSectionOpen("content-hero") ? "is-open" : "")" @onclick='() => ToggleSection("content-hero")'>@(IsSectionOpen("content-hero") ? "閉じる" : "開く")</button>
				</div>
				@if (IsSectionOpen("content-hero"))
				{
					<div class="field">
						<label>imagePc</label>
						<InputFile OnChange="e => OnImageSelected(e, State.Content.Hero.ImagePc)" accept="image/*" />
					</div>
					<div class="field">
						<label>imageSp</label>
						<InputFile OnChange="e => OnImageSelected(e, State.Content.Hero.ImageSp)" accept="image/*" />
					</div>
					<div class="field">
						<label>キャンペーン内容</label>
						<input class="text" @bind-value="State.Content.Hero.Alt" @bind-value:event="oninput" />
					</div>
				}
			</section>

			<section class="panel" data-step="sections">
				<h3>セクション設定</h3>

				<div class="sub-section">
					<div class="sub-header">
						<strong>セクション一覧・設定</strong>
						<button type="button" class="accordion-toggle @(IsSectionOpen("section-list") ? "is-open" : "")" @onclick='() => ToggleSection("section-list")'>@(IsSectionOpen("section-list") ? "閉じる" : "開く")</button>
					</div>
					@if (IsSectionOpen("section-list"))
					{
						<SectionNavigator Search="SectionSearch"
						                 SearchChanged="value => SectionSearch = value"
						                 VisibilityFilter="SectionVisibilityFilter"
						                 VisibilityFilterChanged="value => SectionVisibilityFilter = value"
						                 TypeFilter="SectionTypeFilter"
						                 TypeFilterChanged="value => SectionTypeFilter = value"
						                 TypeOptions="GetSectionTypeOptions()"
						                 MiniMapSections="GetMiniMapSections()"
						                 ActiveId="CurrentPreviewSectionId"
						                 OnMiniMapSelect="OnMiniMapSelectAsync"
						                 FollowActive="FollowActiveSection"
						                 FollowActiveChanged="value => FollowActiveSection = value">
							@if (FilteredSectionGroups.Count == 0)
							{
								<div class="text">該当するセクションがありません。</div>
							}
							else
							{
								@foreach (var group in FilteredSectionGroups)
								{
									var openKey = $"group-{group.Key}";
									var keyLower = group.Key?.ToLowerInvariant() ?? string.Empty;
									var customSection = CustomSectionsSafe.FirstOrDefault(x => string.Equals(x.Key, group.Key, StringComparison.OrdinalIgnoreCase));
									var normalizedKey = NormalizeSectionKey(group.Key);
									var isCurrent = string.Equals(CurrentPreviewSectionId, normalizedKey, StringComparison.OrdinalIgnoreCase);
									var isSelected = string.Equals(SelectedSectionId, group.Key, StringComparison.OrdinalIgnoreCase);
									var title = GetSectionDisplayName(group.Key, group.DisplayName);
									var icon = GetSectionIcon(group.Key, customSection is not null);
									var iconLabel = GetSectionIconLabel(group.Key, customSection is not null);
									var subText = GetSectionSubInfo(group);
									<SectionRow Group="group"
									           RowId="@GetSectionRowId(normalizedKey)"
									           Title="@title"
									           SubText="@subText"
									           Icon="@icon"
									           IconLabel="@iconLabel"
									           IsCurrent="@isCurrent"
									           IsSelected="@isSelected"
									           IsVisible="@group.Enabled"
									           IsHidden="@(!group.Enabled)"
									           IsOpen="@IsSectionOpen(openKey)"
									           OnSelect="() => OnSectionRowSelectedAsync(group)"
									           OnEdit="() => OnSectionEditClickedAsync(group, openKey)"
									           OnToggleChanged="e => OnSectionVisibilityChanged(group, e)"
									           OnToggleOpen="() => ToggleSection(openKey)"
									           OnQuickAction="action => OnSectionRowActionAsync(group, action)"
									           OnMenuAction="action => OnSectionMenuActionAsync(group, action)">
										@if (normalizedKey == "campaigncontent")
											{
												<div class="field">
													<label>セクションタイトル</label>
													<input class="text" @bind-value="State.Content.Sections.CampaignContent.Title" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>テキスト</label>
													<textarea class="text" rows="3" @bind-value="State.Content.Sections.CampaignContent.Body" @bind-value:event="oninput"></textarea>
												</div>
												<div class="field list-field">
													<label>注意事項</label>
													@foreach (var item in State.Content.Sections.CampaignContent.Notes)
													{
														<div class="list-row">
															<input class="text" @bind-value="item.Text" @bind-value:event="oninput" />
															<button type="button" class="btn small" @onclick="() => RemoveItem(State.Content.Sections.CampaignContent.Notes, item)">削除</button>
														</div>
													}
													<button type="button" class="btn small" @onclick="() => AddItem(State.Content.Sections.CampaignContent.Notes)">行追加</button>
												</div>
											}
											else if (normalizedKey == "couponperiod")
											{
												<div class="field">
													<label>セクションタイトル</label>
													<input class="text" @bind-value="State.Content.Sections.CouponPeriod.Title" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>テキスト</label>
													<div class="radio-group">
														<label class="check"><input type="radio" name="couponPeriodMode" value="link" checked="@(State.Content.Sections.CouponPeriod.InputMode == "link")" @onchange="OnCouponPeriodModeChanged" /> キャンペーン期間と連動</label>
														<label class="check"><input type="radio" name="couponPeriodMode" value="calendar" checked="@(State.Content.Sections.CouponPeriod.InputMode == "calendar")" @onchange="OnCouponPeriodModeChanged" /> カレンダーで指定</label>
														<label class="check"><input type="radio" name="couponPeriodMode" value="manual" checked="@(State.Content.Sections.CouponPeriod.InputMode == "manual")" @onchange="OnCouponPeriodModeChanged" /> 手入力</label>
													</div>
													@if (State.Content.Sections.CouponPeriod.InputMode == "link")
													{
														<div class="text text-readonly">@GetCouponPeriodPreviewText()</div>
													}
													else if (State.Content.Sections.CouponPeriod.InputMode == "calendar")
													{
														<div class="field">
															<label>開始日</label>
															<input class="text" type="date" value="@State.Content.Sections.CouponPeriod.StartDate" @onchange="OnCouponPeriodStartChanged" />
														</div>
														<div class="field">
															<label>終了日</label>
															<input class="text" type="date" value="@State.Content.Sections.CouponPeriod.EndDate" @onchange="OnCouponPeriodEndChanged" />
														</div>
														<div class="text text-readonly">@GetCouponPeriodPreviewText()</div>
													}
													else
													{
														<textarea class="text" rows="2" @bind-value="State.Content.Sections.CouponPeriod.Text" @bind-value:event="oninput"></textarea>
													}
													<div class="field">
														<label>テキストサイズ</label>
														<select class="text" @onchange="OnCouponPeriodTextSizeChanged">
															<option value="">自動</option>
															@foreach (var size in FontSizeOptions)
															{
																<option value="@size" selected="@(State.Content.Sections.CouponPeriod.TextFontSize == size)">@size px</option>
															}
														</select>
													</div>
												</div>
											}
											else if (normalizedKey == "couponflow")
											{
												<div class="field">
													<label>セクションタイトル</label>
													<input class="text" @bind-value="State.Content.Sections.CouponFlow.Title" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>リード文</label>
													<textarea class="text" rows="2" @bind-value="State.Content.Sections.CouponFlow.Lead" @bind-value:event="oninput"></textarea>
													<div class="hint">&lt;strong&gt;...&lt;/strong&gt;などのHTMLが使用できます。</div>
												</div>
												<div class="field list-field">
													<label>スライド</label>
													@foreach (var slide in State.Content.Sections.CouponFlow.Slides)
													{
														<div class="list-row">
															<div class="input-row">
																<input class="text" @bind-value="slide.Image" @bind-value:event="oninput" />
																<InputFile OnChange="e => OnImageSelected(e, slide.Image)" accept="image/*" />
															</div>
															<input class="text" placeholder="代替テキスト" @bind-value="slide.Alt" @bind-value:event="oninput" />
															<button type="button" class="btn small" @onclick="() => RemoveCouponFlowSlide(slide)">削除</button>
														</div>
													}
													<button type="button" class="btn small" @onclick="AddCouponFlowSlide">スライド追加</button>
												</div>
												<div class="field">
													<label>注記</label>
													<input class="text" @bind-value="State.Content.Sections.CouponFlow.Note" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>ボタンラベル</label>
													<input class="text" @bind-value="State.Content.Sections.CouponFlow.ButtonLabel" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>ボタンURL</label>
													<input class="text" @bind-value="State.Content.Sections.CouponFlow.ButtonUrl" @bind-value:event="oninput" placeholder="https://..." />
												</div>
												<div class="field list-field">
													<label>注意書き</label>
													@foreach (var item in State.Content.Sections.CouponFlow.Items)
													{
														<div class="list-row">
															<input class="text" @bind-value="item.Text" @bind-value:event="oninput" />
															<button type="button" class="btn small" @onclick="() => RemoveItem(State.Content.Sections.CouponFlow.Items, item)">削除</button>
														</div>
													}
													<button type="button" class="btn small" @onclick="() => AddItem(State.Content.Sections.CouponFlow.Items)">行追加</button>
												</div>
											}
											else if (normalizedKey == "stickytabs")
											{
												var stickyTabs = State.Content.Sections.StickyTabs;
														<div class="sticky-tabs-editor">
															<div class="sticky-tabs-editor__tabbar">
																<div class="sticky-tabs-editor__tabs">
																	@for (var tabIndex = 0; tabIndex < stickyTabs.Tabs.Count; tabIndex++)
																	{
																	var currentIndex = tabIndex;
																	var tab = stickyTabs.Tabs[currentIndex];
																	var isActive = currentIndex == SelectedStickyTabIndex;
																	var tabBg = string.IsNullOrWhiteSpace(tab.Color) ? "#e5e7eb" : tab.Color;
																	var tabTextColor = ResolveStickyTabEditorTextColor(tabBg, tab.TextColor);
																		<button type="button" class="sticky-tabs-editor__tab@(isActive ? " is-active" : string.Empty)" style="--tab-bg:@tabBg; --tab-color:@tabTextColor;" title="@tab.Title" @onclick="() => SelectStickyTab(currentIndex)">
																			<span class="sticky-tabs-editor__tabTitle">@tab.Title</span>
																			@if (isActive)
																			{
																				<span class="sticky-tabs-editor__tabActions">
																					<span class="sticky-tabs-editor__icon" role="button" tabindex="0" title="左へ" @onclick:stopPropagation="true" @onclick="() => MoveStickyTab(currentIndex, -1)">←</span>
																					<span class="sticky-tabs-editor__icon" role="button" tabindex="0" title="右へ" @onclick:stopPropagation="true" @onclick="() => MoveStickyTab(currentIndex, 1)">→</span>
																					<span class="sticky-tabs-editor__icon" role="button" tabindex="0" title="複製" @onclick:stopPropagation="true" @onclick="() => DuplicateStickyTab(currentIndex)">⧉</span>
																					<span class="sticky-tabs-editor__icon is-danger" role="button" tabindex="0" title="削除" @onclick:stopPropagation="true" @onclick="() => RemoveStickyTabWithConfirm(currentIndex)">🗑</span>
																				</span>
																			}
																		</button>
																	}
																	<button type="button" class="sticky-tabs-editor__addTab" @onclick="AddStickyTab">＋ タブ追加</button>
																</div>
															</div>

															@if (stickyTabs.Tabs.Count == 0)
															{
																<div class="text text-readonly">タブを追加してください。</div>
															}
															else
															{
																var activeIndex = Math.Clamp(SelectedStickyTabIndex, 0, stickyTabs.Tabs.Count - 1);
																var activeTab = stickyTabs.Tabs[activeIndex];
																<div class="sticky-tabs-editor__layout">
																	<div class="sticky-tabs-editor__blocks">
																		<div class="sticky-tabs-editor__sectionTitle">Blocks</div>
																		@for (var blockIndex = 0; blockIndex < activeTab.ContentBlocks.Count; blockIndex++)
																		{
																			var currentBlockIndex = blockIndex;
																			var block = activeTab.ContentBlocks[currentBlockIndex];
																			<div class="sticky-tabs-editor__blockCard">
																				<div class="sticky-tabs-editor__blockHeader">
																					<span class="sticky-tabs-editor__blockType">@GetStickyBlockTypeLabel(block.Type)</span>
																					<div class="sticky-tabs-editor__blockActions">
																						<button type="button" class="sticky-tabs-editor__icon" title="上へ" @onclick="() => MoveStickyBlock(activeTab, currentBlockIndex, -1)">↑</button>
																						<button type="button" class="sticky-tabs-editor__icon" title="下へ" @onclick="() => MoveStickyBlock(activeTab, currentBlockIndex, 1)">↓</button>
																						<button type="button" class="sticky-tabs-editor__icon" title="複製" @onclick="() => DuplicateStickyBlock(activeTab, currentBlockIndex)">⧉</button>
																						<button type="button" class="sticky-tabs-editor__icon is-danger" title="削除" @onclick="() => RemoveStickyBlock(activeTab, currentBlockIndex)">🗑</button>
																					</div>
																				</div>
																				<div class="sticky-tabs-editor__blockBody">
																					<select class="sticky-tabs-editor__select" @bind-value="block.Type" @bind-value:event="onchange">
																						<option value="RichText">リッチテキスト</option>
																						<option value="Image">画像</option>
																						<option value="ImageWithCaption">画像+キャプション</option>
																						<option value="Divider">区切り線</option>
																					</select>

																					@if (block.Type == StickyBlockType.RichText)
																					{
																						<textarea class="sticky-tabs-editor__textarea" rows="5" @bind-value="block.RichTextHtml" @bind-value:event="oninput"></textarea>
																						<div class="sticky-tabs-editor__hint">改行は自動で&lt;br&gt;になります。</div>
																					}

																					else if (block.Type == StickyBlockType.Image || block.Type == StickyBlockType.ImageWithCaption)
																					{
																						<div class="sticky-tabs-editor__imageRow">
																							<input class="sticky-tabs-editor__input" @bind-value="block.ImageSrc" @bind-value:event="oninput" placeholder="images/example.png" />
																							<InputFile OnChange="e => OnImageSelected(e, block.ImageSrc)" accept="image/*" />
																						</div>
																						@if (block.Type == StickyBlockType.ImageWithCaption)
																						{
																							<input class="sticky-tabs-editor__input" placeholder="キャプション" @bind-value="block.Caption" @bind-value:event="oninput" />
																						}
																					}

																					else
																					{
																						<div class="sticky-tabs-editor__note">区切り線を表示します。</div>
																					}
																				</div>
																			</div>
																		}

																		<div class="sticky-tabs-editor__blockAdd">
																			<select class="sticky-tabs-editor__select" @bind-value="NewStickyBlockType" @bind-value:event="onchange">
																				<option value="RichText">リッチテキスト</option>
																				<option value="Image">画像</option>
																				<option value="ImageWithCaption">画像+キャプション</option>
																				<option value="Divider">区切り線</option>
																			</select>
																			<button type="button" class="sticky-tabs-editor__addBlock" @onclick="() => AddStickyBlock(activeTab, NewStickyBlockType)">＋ ブロック追加</button>
																	</div>
																</div>

																<div class="sticky-tabs-editor__props">
																	<div class="sticky-tabs-editor__sectionTitle">Properties</div>
																	<div class="sticky-tabs-editor__propCard">
																		<label class="sticky-tabs-editor__label">選択タブタイトル</label>
																		<input class="sticky-tabs-editor__input" @bind-value="activeTab.Title" @bind-value:event="oninput" />
																		<div class="sticky-tabs-editor__divider"></div>

																		<label class="sticky-tabs-editor__label">タブ背景色</label>
																		<div class="sticky-tabs-editor__colorRow">
																			<input class="sticky-tabs-editor__input" @bind-value="activeTab.Color" @bind-value:event="oninput" placeholder="#d91f2a" />
																			<input type="color" value="@ToColorPickerValue(activeTab.Color)" @oninput="(e) => SetStickyTabColor(activeTab, e?.Value?.ToString())" />
																		</div>
																		<div class="sticky-tabs-editor__swatches">
																			@foreach (var paletteColor in StickyTabPalette)
																			{
																				<button type="button" class="sticky-tabs-editor__swatch" style="background:@paletteColor" title="@paletteColor" @onclick="() => SetStickyTabColor(activeTab, paletteColor)"></button>
																			}
																		</div>

																		<label class="sticky-tabs-editor__label">タブ文字色</label>
																		<div class="sticky-tabs-editor__row">
																			<label class="sticky-tabs-editor__checkbox">
																				<input type="checkbox" checked="@IsStickyTabTextAuto(activeTab)" @onchange="(e) => SetStickyTabTextColorMode(activeTab, e)" />
																				<span>自動</span>
																			</label>
																			@if (!IsStickyTabTextAuto(activeTab))
																			{
																				<button type="button" class="sticky-tabs-editor__textBtn" @onclick='() => SetStickyTabTextColor(activeTab, "#111827")'>濃色</button>
																				<button type="button" class="sticky-tabs-editor__textBtn" @onclick='() => SetStickyTabTextColor(activeTab, "#ffffff")'>白</button>
																			}
																		</div>

																		<div class="sticky-tabs-editor__danger">
																			<button type="button" class="sticky-tabs-editor__dangerBtn" @onclick="() => RemoveStickyTabWithConfirm(activeIndex)">タブを削除</button>
																		</div>
																	</div>
																</div>
															</div>
														}
													</div>
											}
											else if (normalizedKey.StartsWith("storesearch"))
											{
												<div class="field">
													<label>セクションタイトル</label>
													<input class="text" @bind-value="State.Content.Sections.StoreSearch.Title" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>注意文タイトル</label>
													<input class="text" @bind-value="State.Content.Sections.StoreSearch.NoticeTitle" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>店舗リスト（Excel）</label>
													<InputFile OnChange="OnStoreExcelSelected" accept=".xlsx" />
													<div class="hint">固定カラム: 店舗ID / 店舗名 / 郵便番号 / 住所 / 緯度 / 経度。以降の列は対象ラベルとして扱い、値が「対象/TRUE/○/はい」で対象になります。</div>
												</div>
															@* StoreSearch.NoticeItems(TextItemModel) -> StoreSearch.NoticeLines(StyledTextItem) *@
															<TextLinesEditor Title="注意文"
															                 Items="State.Content.Sections.StoreSearch.NoticeLines"
															                 AllowDelete="true"
															                 OnChanged="OnStoreSearchNoticeLinesChanged"
															                 FontSizeOptions="FontSizeOptions"
															                 FontFamilyOptions="FontFamilyOptions"
															                 GetColorValue="GetColorValue" />
															<div class="sub-header" style="margin-top:12px;">
																<strong>対象ラベル</strong>
															</div>
															@if (State.Content.Sections.StoreSearch.TargetLabels.Count == 0)
															{
																<div class="text text-readonly">店舗リスト読み込み後にラベルが表示されます。</div>
															}
															else
															{
																<StoreTargetLabelManager Labels="State.Content.Sections.StoreSearch.TargetLabels" OnChanged="OnAnyInputAfter" />
															}
											}
											else if (normalizedKey == "couponnotes")
											{
												<div class="field">
													<label>セクションタイトル</label>
													<input class="text" @bind-value="State.Content.Sections.CouponNotes.Title" @bind-value:event="oninput" />
												</div>
															@* CouponNotes.Items(TextItemModel) -> CouponNotes.TextLines(StyledTextItem) *@
															<TextLinesEditor Title="注意事項に記載する文言"
															                 Items="State.Content.Sections.CouponNotes.TextLines"
															                 AllowDelete="true"
															                 OnChanged="OnCouponNotesLinesChanged"
															                 FontSizeOptions="FontSizeOptions"
															                 FontFamilyOptions="FontFamilyOptions"
															                 GetColorValue="GetColorValue" />
											}
											else if (normalizedKey == "ranking")
											{
												var headerCount = GetRankingHeaderCount();
												<RankingEditor
													Ranking="State.Content.Sections.Ranking"
													HeaderCount="headerCount"
													OnAnyInputAfter="OnAnyInputAfter"
													AddRankingHeader="AddRankingHeader"
													AddRankingRow="AddRankingRow"
													RemoveRankingRow="RemoveRankingRow"
													OnImageLeftSelected="OnRankingLeftImageSelected"
													OnImageRightSelected="OnRankingRightImageSelected"
													FontFamilyOptions="FontFamilyOptions"
													FontSizeOptions="FontSizeOptions"
													GetColorValue="GetColorValue" />
											}
											else if (normalizedKey == "paymenthistory")
											{
												<div class="field">
													<label>見出しテキスト</label>
													<input class="text" @bind-value="State.Content.Sections.PaymentHistory.TitleText" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>本文</label>
													<textarea class="text" rows="3" @bind-value="State.Content.Sections.PaymentHistory.Text" @bind-value:event="oninput"></textarea>
													<div class="hint">改行は&lt;br&gt;、問い合わせリンクは&lt;a href=&quot;#contact&quot;&gt;...&lt;/a&gt;で記述できます。</div>
												</div>
												<div class="field">
													<label>強調文</label>
													<textarea class="text" rows="2" @bind-value="State.Content.Sections.PaymentHistory.ImportantText" @bind-value:event="oninput"></textarea>
												</div>
												<div class="field">
													<label>画像</label>
													<div class="input-row">
														<input class="text" @bind-value="State.Content.Sections.PaymentHistory.Image" @bind-value:event="oninput" />
														<InputFile OnChange="e => OnImageSelected(e, State.Content.Sections.PaymentHistory.Image)" accept="image/*" />
													</div>
												</div>
												<div class="field">
													<label>画像代替テキスト</label>
													<input class="text" @bind-value="State.Content.Sections.PaymentHistory.ImageAlt" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>装飾画像</label>
													<div class="input-row">
														<input class="text" @bind-value="State.Content.Sections.PaymentHistory.DecoImage" @bind-value:event="oninput" />
														<InputFile OnChange="e => OnImageSelected(e, State.Content.Sections.PaymentHistory.DecoImage)" accept="image/*" />
													</div>
												</div>
												<div class="field">
													<label>装飾画像代替テキスト</label>
													<input class="text" @bind-value="State.Content.Sections.PaymentHistory.DecoAlt" @bind-value:event="oninput" />
												</div>
											}
											else if (normalizedKey.Contains("conditionscontactbanners"))
											{
												<div class="text text-readonly">詳細設定は未対応です。</div>
											}
											else if (normalizedKey == "conditions")
											{
												<div class="text text-readonly">詳細設定は未対応です。</div>
											}
											else if (keyLower == "contact")
											{
												<div class="text text-readonly">詳細設定は未対応です。</div>
											}
											else if (keyLower.Contains("banners") || keyLower.Contains("banner"))
											{
												<div class="text text-readonly">バナー周辺のテキストに適用します。</div>
											}
											else if (keyLower == "countdown")
											{
												<div class="field">
													<label>開始日</label>
													<input class="text" type="date" value="@State.Content.Campaign.StartDate" @onchange="OnCampaignStartChanged" />
												</div>
												<div class="field">
													<label>終了日</label>
													<input class="text" type="date" value="@State.Content.Campaign.EndDate" @onchange="OnCampaignEndChanged" />
												</div>
												<div class="field">
													<label>カウントダウン表示</label>
													<label class="check"><input type="checkbox" @bind="State.Content.Campaign.ShowCountdown" @bind:after="OnAnyInputAfter" /> 表示する</label>
												</div>
													<div class="field">
														<label>フッターテキストサイズ</label>
														<select class="text" @onchange="OnCountdownTextSizeChanged">
															<option value="">自動</option>
															@foreach (var size in FontSizeOptions)
															{
																<option value="@size" selected="@(State.Content.Campaign.CountdownTextSize == size)">@size px</option>
															}
														</select>
													</div>
												@if (State.Content.Campaign.ShowCountdown)
												{
													<div class="field">
														<label>カウントダウン終了日時</label>
														<input class="text" type="datetime-local" value="@State.Content.Campaign.CountdownEnd" @onchange="OnCountdownEndInputChanged" />
													</div>
												}
												<div class="field">
													<label>終了メッセージ</label>
													<input class="text" @bind-value="State.Content.Campaign.EndedMessage" @bind-value:event="oninput" />
												</div>
														@* Campaign.EndedMessage(旧単行) -> Campaign.FooterLines(StyledTextItem) *@
														<TextLinesEditor Title="フッターテキスト"
														                 Items="State.Content.Campaign.FooterLines"
														                 AllowDelete="true"
														                 OnChanged="OnFooterLinesChanged"
														                 FontSizeOptions="FontSizeOptions"
														                 FontFamilyOptions="FontFamilyOptions"
														                 GetColorValue="GetColorValue" />
											}
											else if (customSection is not null)
											{
												<div class="field">
													<label>セクションタイトル</label>
													<input class="text" @bind-value="customSection.Title" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>テキスト</label>
													<TextLinesEditor Title=""
													                 Items="customSection.BodyTextItems"
													                 AllowDelete="true"
													                 AllowEmpty="true"
													                 DefaultAlign="left"
													                 OnChanged="OnCustomSectionLinesChanged"
													                 FontSizeOptions="FontSizeOptions"
													                 FontFamilyOptions="FontFamilyOptions"
													                 GetColorValue="GetColorValue" />
												</div>
												<div class="field">
													<label>画像</label>
													<div class="image-row">
														<input class="text" @bind-value="customSection.ImagePath" @bind-value:event="oninput" />
														<InputFile OnChange="e => OnImageSelected(e, customSection.ImagePath)" accept="image/*" />
													</div>
												</div>
												<div class="field">
													<label>画像代替テキスト</label>
													<input class="text" @bind-value="customSection.ImageAlt" @bind-value:event="oninput" />
												</div>
												<div class="field">
													<label>画像下の注意事項</label>
													<TextLinesEditor Title=""
													                 Items="customSection.ImageNotesItems"
													                 AllowDelete="true"
													                 AllowEmpty="true"
													                 DefaultAlign="left"
													                 OnChanged="OnCustomSectionLinesChanged"
													                 FontSizeOptions="FontSizeOptions"
													                 FontFamilyOptions="FontFamilyOptions"
													                 GetColorValue="GetColorValue" />
												</div>
												<div class="field">
													<label>リンクURL</label>
													<input class="text" @bind-value="customSection.LinkUrl" @bind-value:event="oninput" placeholder="https://..." />
												</div>
												<div class="actions">
													<button type="button" class="btn small" @onclick="() => RemoveCustomSection(customSection)">削除</button>
												</div>
											}
											else
											{
											@if (!IsImportMode && IsEditorManagedSectionKey(group.Key))
											{
												var decorStyle = GetSectionStyleSettings(group.Key ?? string.Empty);
												<div class="sub-header" style="margin-top:12px;">
													<strong>装飾</strong>
												</div>
												<DecorationsPanel Style="decorStyle"
												                 DecoImageOptions="State.DecoImagePaths"
												                 OnChanged="OnAnyInputAfter" />
											}
												<div class="text text-readonly">このセクションは詳細設定がありません。</div>
											}

										</SectionRow>
									}
								}
						</SectionNavigator>
					}
					<div class="actions" style="margin-top:12px;">
						<button type="button" class="btn small" @onclick="AddRankingSection">ランキングセクション追加</button>
						<button type="button" class="btn small" @onclick="AddPaymentHistorySection">決済履歴の確認方法セクション追加</button>
						<button type="button" class="btn small" @onclick="AddCouponFlowSection">クーポン利用方法セクション追加</button>
						<button type="button" class="btn small" @onclick="AddStickyTabsSection">付箋タブセクション追加</button>
						<button type="button" class="btn small" @onclick="AddCustomSection">通常セクション追加</button>
						<button type="button" class="btn small" @onclick="AddStoreSearchSection">店舗検索セクション追加</button>
					</div>
				</div>

			</section>

			</div>
			</EditForm>
			}
		}
	</div>
	<div class="splitter" id="previewSplitter" aria-hidden="true"></div>
	<div class="preview-pane" id="previewPane">
		<div class="preview-loading @(IsPreviewLoading ? "active" : "")">
			<div class="preview-loading-card">
				<div class="preview-loading-title">プレビューを更新中</div>
				<div class="preview-loading-bar"></div>
				<div class="preview-loading-sub">反映まで少々お待ちください</div>
			</div>
		</div>
		<div class="preview-toolbar">
			<div class="toolbar-group">
				<button class="toolbar-btn @(!State.PreviewIsMobile && !IsResponsivePreview ? "is-active" : "")" type="button" @onclick="() => SetPreviewMode(false)">
					<span class="tool-icon" aria-hidden="true">
						<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
							<rect x="3" y="4" width="18" height="12" rx="2"></rect>
							<path d="M8 20h8"></path>
							<path d="M12 16v4"></path>
						</svg>
					</span>
					<span>PC</span>
				</button>
				<button class="toolbar-btn @(State.PreviewIsMobile && !IsResponsivePreview ? "is-active" : "")" type="button" @onclick="() => SetPreviewMode(true)">
					<span class="tool-icon" aria-hidden="true">
						<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
							<rect x="7" y="3" width="10" height="18" rx="2"></rect>
							<circle cx="12" cy="17" r="1"></circle>
						</svg>
					</span>
					<span>SP</span>
				</button>
			</div>
			<div class="toolbar-group">
				<button class="toolbar-btn @(PreviewMode == "final" ? "is-active" : "")" type="button" @onclick="TogglePreviewModeAsync">
					<span class="tool-icon" aria-hidden="true">
						<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
							<path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path>
							<circle cx="12" cy="12" r="3"></circle>
						</svg>
					</span>
					<span>完成プレビュー</span>
					<span class="toolbar-badge">@(PreviewMode == "final" ? "ON" : "OFF")</span>
				</button>
				<button class="toolbar-btn" type="button" @onclick="() => ScrollPreviewToSectionAsync(SelectedSectionId)">
					<span class="tool-icon" aria-hidden="true">
						<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
							<circle cx="12" cy="12" r="8"></circle>
							<circle cx="12" cy="12" r="3"></circle>
							<path d="M12 2v3"></path>
							<path d="M12 19v3"></path>
							<path d="M2 12h3"></path>
							<path d="M19 12h3"></path>
						</svg>
					</span>
					<span>選択セクションへ</span>
				</button>
			</div>
			<div class="toolbar-group">
				<div class="toolbar-field">
					<span class="tool-icon" aria-hidden="true">
						<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
							<rect x="3" y="5" width="12" height="8" rx="2"></rect>
							<rect x="15" y="9" width="6" height="10" rx="2"></rect>
						</svg>
					</span>
					<InputSelect class="responsive-select" @bind-Value="SelectedResponsiveDevice" @bind-Value:after="OnResponsiveDeviceChanged">
						<option value="">デバイス選択</option>
						@foreach (var device in ResponsiveDevices)
						{
							<option value="@device.Key">@device.Label (@device.Width×@device.Height)</option>
						}
					</InputSelect>
				</div>
				@if (State.PreviewIsMobile || IsResponsivePreview)
				{
					<button class="toolbar-btn" type="button" @onclick="ToggleOrientation">
						<span class="tool-icon" aria-hidden="true">
							<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
								<path d="M4 4v6h6"></path>
								<path d="M20 20v-6h-6"></path>
								<path d="M5 19a7 7 0 0 0 12-4"></path>
								<path d="M19 5a7 7 0 0 0-12 4"></path>
							</svg>
						</span>
						<span>回転</span>
						<span class="toolbar-badge">@(IsLandscape ? "横" : "縦")</span>
					</button>
				}
				@if (IsResponsivePreview)
				{
					<div class="toolbar-field">
						<span class="tool-icon" aria-hidden="true">
							<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
								<circle cx="11" cy="11" r="6"></circle>
								<path d="M21 21l-4.2-4.2"></path>
							</svg>
						</span>
						<InputSelect class="responsive-select" @bind-Value="ResponsiveDpr" @bind-Value:after="OnResponsiveDprChanged">
							<option value="1">DPR 1</option>
							<option value="1.5">DPR 1.5</option>
							<option value="2">DPR 2</option>
							<option value="2.5">DPR 2.5</option>
							<option value="2.625">DPR 2.625</option>
							<option value="3">DPR 3</option>
							<option value="3.5">DPR 3.5</option>
							<option value="4">DPR 4</option>
						</InputSelect>
					</div>
				}
			</div>
		</div>
		<div id="previewFrameWrapper" class="preview-frame-wrapper @(IsResponsivePreview ? "is-responsive" : (State.PreviewIsMobile ? "is-mobile" : "is-pc"))" style="--responsive-width: @($"{EffectiveResponsiveWidth}px"); --responsive-height: @($"{EffectiveResponsiveHeight}px"); --preview-scale: 1; --preview-scaled-width: @($"{EffectiveResponsiveWidth}px"); --preview-scaled-height: @($"{EffectiveResponsiveHeight}px");">
			<div class="preview-device @(IsResponsivePreview ? "responsive" : (State.PreviewIsMobile ? "mobile" : "pc"))">
				<iframe id="previewFrame" allow="geolocation" class="preview-frame @(IsResponsivePreview ? "responsive" : (State.PreviewIsMobile ? "mobile" : "pc"))" style="@GetPreviewFrameStyle()" srcdoc="@State.PreviewHtml" @key="PreviewVersion"></iframe>
			</div>
		</div>
	</div>
</div>

@code {
	private EditContext? EditContext;
	private string OutputZipPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "lp-output.zip");
	private string ContentSavePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "content.json");
	private string ActiveTab = "content";
	private static readonly int[] FontSizeOptions = Enumerable.Range(12, 39).ToArray();
	private static readonly FontFamilyOption[] FontFamilyOptions =
	{
		new("標準", ""),
		new("Noto Sans JP", "\"Noto Sans JP\", \"Yu Gothic\", \"Hiragino Kaku Gothic ProN\", sans-serif"),
		new("Noto Serif JP", "\"Noto Serif JP\", \"Yu Mincho\", \"Hiragino Mincho ProN\", serif"),
		new("M PLUS 1p", "\"M PLUS 1p\", \"Yu Gothic\", \"Hiragino Kaku Gothic ProN\", sans-serif"),
		new("M PLUS Rounded 1c", "\"M PLUS Rounded 1c\", \"Yu Gothic\", \"Hiragino Kaku Gothic ProN\", sans-serif"),
		new("游ゴシック", "\"Yu Gothic\", \"YuGothic\", \"Hiragino Kaku Gothic ProN\", sans-serif"),
		new("メイリオ", "\"Meiryo\", \"Hiragino Kaku Gothic ProN\", sans-serif"),
		new("MS Pゴシック", "\"MS PGothic\", \"Yu Gothic\", \"Hiragino Kaku Gothic ProN\", sans-serif"),
		new("Segoe UI", "\"Segoe UI\", \"Helvetica Neue\", Arial, sans-serif"),
		new("Roboto", "\"Roboto\", \"Segoe UI\", Arial, sans-serif"),
		new("Open Sans", "\"Open Sans\", \"Segoe UI\", Arial, sans-serif"),
		new("Montserrat", "\"Montserrat\", \"Segoe UI\", Arial, sans-serif"),
		new("明朝", "\"Yu Mincho\", \"Hiragino Mincho ProN\", serif"),
		new("MS 明朝", "\"MS Mincho\", \"Yu Mincho\", \"Hiragino Mincho ProN\", serif")
	};
	private static readonly KeyValuePair<string, string>[] BackgroundPresetOptions =
	{
		new("なし", ""),
		new("グラデーション(ロイヤル)", "gradient-royal"),
		new("グラデーション(サンセット)", "gradient-sunset"),
		new("ドット", "dots"),
		new("ストライプ", "stripes"),
		new("グリッド", "grid")
	};
	private IReadOnlyList<BackgroundPresetModel> BackgroundPresets = Array.Empty<BackgroundPresetModel>();
	private static readonly KeyValuePair<string, string>[] TextAlignOptions =
	{
		new("左", "left"),
		new("中央", "center"),
		new("右", "right")
	};
	private readonly List<string> RecentCardColors = new();
	private CancellationTokenSource? _designPreviewCts;
	private Action<HighlightRequest>? _highlightHandler;
	private bool _pendingBandHighlight;
	private int? TemplateTextFontSize;
	private bool IsPreviewLoading;
	private int PreviewVersion;
	private bool IsResponsivePreview;
	private bool IsLandscape;
	private int ResponsiveWidth = 375;
	private int ResponsiveHeight = 667;
	private double ResponsiveDpr = 1;
	private string SelectedResponsiveDevice = string.Empty;
	private BackgroundSetting PageBackgroundSetting = new();
	private bool UseViewportSizing;
	private bool HasPreviewModeSelection;
	private const int PcPreviewWidth = 1280;
	private const int PcPreviewHeight = 800;
	private const int SpPreviewWidth = 390;
	private const int SpPreviewHeight = 667;
	private static readonly ResponsiveDeviceOption[] ResponsiveDevices =
	{
		new("iphone-se", "iPhone SE", 375, 667, 2),
		new("iphone-xr", "iPhone XR", 414, 896, 2),
		new("iphone-12-pro", "iPhone 12 Pro", 390, 844, 3),
		new("iphone-14-pro-max", "iPhone 14 Pro Max", 430, 932, 3),
		new("pixel-7", "Pixel 7", 412, 915, 2.625),
		new("galaxy-s8-plus", "Samsung Galaxy S8+", 360, 740, 4),
		new("galaxy-s20-ultra", "Samsung Galaxy S20 Ultra", 412, 915, 3.5),
		new("galaxy-a51-71", "Samsung Galaxy A51 / 71", 412, 914, 2.625),
		new("ipad-mini", "iPad Mini", 768, 1024, 2),
		new("ipad-air", "iPad Air", 820, 1180, 2),
		new("ipad-pro", "iPad Pro", 1024, 1366, 2),
		new("surface-pro-7", "Surface Pro 7", 912, 1368, 2),
		new("surface-duo", "Surface Duo", 540, 720, 2.5),
		new("zenbook-fold", "Asus Zenbook Fold", 853, 1280, 2),
		new("galaxy-z-fold-5-folded", "Galaxy Z Fold 5 (折)", 344, 882, 3),
		new("galaxy-z-fold-5-open", "Galaxy Z Fold 5 (展開)", 720, 882, 2.5),
		new("nest-hub", "Nest Hub", 1024, 600, 1),
		new("nest-hub-max", "Nest Hub Max", 1280, 800, 1)
	};
	private BulkTextStyle CampaignNotesBulk = new();
	private BulkTextStyle StoreSearchNotesBulk = new();
	private BulkTextStyle CouponNotesBulk = new();
	private bool _couponNotesLinesInitialized;
	private bool _storeSearchNoticeLinesInitialized;
	private bool _footerLinesInitialized;
	private readonly HashSet<string> _customSectionLinesInitialized = new(StringComparer.OrdinalIgnoreCase);
	private string SelectedSectionId = string.Empty;
	private string CurrentPreviewSectionId = string.Empty;
	private string SectionSearch = string.Empty;
	private string SectionVisibilityFilter = "all";
	private string SectionTypeFilter = "all";
	private bool FollowActiveSection = true;
	private string FrameThemeTab = "common";
	private string FrameThemeSectionKey = string.Empty;
	private IReadOnlyList<KeyValuePair<string, string>> DesignSectionOptions = Array.Empty<KeyValuePair<string, string>>();
	private string FrameAnimationScope = "per";
	private string PreviewMode = "edit";
	private LpImportSession? ImportSession;
	private LpImportProject? ImportProject;
	private string? ImportEntryHtmlPath;
	private bool IsImporting;
	private string ImportStage = string.Empty;
	private string SelectedImportSectionId = string.Empty;

	private bool IsImportMode => ImportProject?.IsReady == true;
	private LpImportSection? SelectedImportSection => ImportProject?.Sections.FirstOrDefault(section => section.Id == SelectedImportSectionId);

	protected override async Task OnInitializedAsync()
	{
		EnsureContentCollections();
		SetupEditContext();
		InitializeAccordionDefaults();
		EnsureSectionTextLines();
		EnsureSectionSelection();
		RefreshDesignSectionOptions();
		EnsureFrameThemeSectionKey();
		EnsureFrameDefaultStyle();
		CleanFrameOverrideData();
		SyncPageBackgroundSetting();
		RegisterHighlightListener();
		BackgroundPresets = await BackgroundPresetService.GetPresetsAsync();
	}

	private void EnsureSectionSelection()
	{
		RefreshDesignSectionOptions();
		if (string.IsNullOrWhiteSpace(SelectedSectionId))
		{
			SelectedSectionId = State.Content.SectionGroups.FirstOrDefault()?.Key ?? string.Empty;
		}
	}

	private void SetupEditContext()
	{
		EditContext = new EditContext(State.Content);
		EditContext.OnFieldChanged += async (_, _) => await UpdatePreviewAsync();
	}

	private void RegisterHighlightListener()
	{
		if (_highlightHandler is not null)
		{
			return;
		}

		_highlightHandler = request => _ = InvokeAsync(async () =>
		{
			try
			{
				await JS.InvokeVoidAsync("lpHighlight.request", "previewFrame", request);
			}
			catch
			{
				// no-op
			}
		});

		HighlightService.OnRequested += _highlightHandler;
	}

	private void SetTab(string tab)
	{
		ActiveTab = tab;
	}


	private IReadOnlyList<StepNavItem> GetStepItems()
	{
		var templateReady = IsImportMode ? ImportProject is not null : State.Template is not null;
		var contentReady = IsImportMode
			? (ImportProject?.Stats.EditableTextCount > 0 || ImportProject?.Stats.EditableImageCount > 0 || ImportProject?.Stats.EditableLinkCount > 0)
			: !string.IsNullOrWhiteSpace(State.Content.Sections.CampaignContent.Title);
		var decorReady = IsImportMode
			? (ImportProject?.Sections.Any(section => !section.IsFrozen) ?? false)
			: State.Content.SectionStyles.Count > 0;
		return new List<StepNavItem>
		{
			new() { Id = "template", Index = 1, Label = "テンプレ選択", IsComplete = templateReady, IsActive = ActiveTab == "basic" },
			new() { Id = "content", Index = 2, Label = "セクション内容編集", IsComplete = contentReady, IsActive = ActiveTab == "content" },
			new() { Id = "decor", Index = 3, Label = "セクション装飾", IsComplete = decorReady, IsActive = ActiveTab == "content" },
			new() { Id = "background", Index = 4, Label = "背景調整", IsComplete = !string.IsNullOrWhiteSpace(State.Content.LpBackground.Color) || !string.IsNullOrWhiteSpace(State.Content.LpBackground.ImageUrl), IsActive = ActiveTab == "design" },
			new() { Id = "check", Index = 5, Label = "出力チェック", IsComplete = GetSafetyIssues().Count == 0, IsActive = ActiveTab == "basic" }
		};
	}

	private async Task OnStepSelected(string stepId)
	{
		switch (stepId)
		{
			case "template":
				SetTab("basic");
				ToggleSection(IsImportMode ? "basic-import" : "basic-template");
				await ScrollToEditorAsync(IsImportMode ? "[data-step='import']" : "[data-step='template']");
				break;
			case "content":
				SetTab("content");
				if (IsImportMode)
				{
					await ScrollToEditorAsync("#importSectionList");
				}
				else
				{
					ToggleSection("section-list");
					await ScrollToEditorAsync("#sectionList");
				}
				break;
			case "decor":
				SetTab("content");
				if (IsImportMode)
				{
					await ScrollToEditorAsync("#importSectionList");
				}
				else
				{
					ToggleSection("section-list");
					await ScrollToEditorAsync("#sectionList");
					await TriggerHighlightAsync(SelectedSectionId, "decor");
				}
				break;
			case "background":
				SetTab("design");
				await ScrollToEditorAsync("[data-step='background']");
				await TriggerHighlightAsync(string.Empty, "background");
				break;
			case "check":
				SetTab("basic");
				await ScrollToEditorAsync("[data-step='check']");
				break;
		}
	}

	private async Task SelectSection(string? key)
	{
		SelectedSectionId = key ?? string.Empty;
		if (!string.IsNullOrWhiteSpace(SelectedSectionId))
		{
			await TriggerHighlightAsync(SelectedSectionId, "section");
		}
	}

	private async Task TriggerHighlightAsync(string sectionKey, string kind)
	{
		HighlightService.Trigger(BuildHighlightRequest(sectionKey, kind));
		await Task.CompletedTask;
	}

	private HighlightRequest BuildHighlightRequest(string? sectionKey, string? kind)
	{
		var normalizedKind = kind?.Trim().ToLowerInvariant() ?? string.Empty;
		return normalizedKind switch
		{
			"background" => new HighlightRequest
			{
				ScopeType = "page",
				Style = "wash",
				DurationMs = 320
			},
			"decor" => new HighlightRequest
			{
				ScopeType = "section",
				Id = NormalizeHighlightId(sectionKey),
				Style = "outline",
				DurationMs = 320
			},
			_ => new HighlightRequest
			{
				ScopeType = "section",
				Id = NormalizeHighlightId(sectionKey),
				Style = "glow",
				DurationMs = 320
			}
		};
	}

	private void TriggerPageHighlight()
	{
		HighlightService.Trigger(new HighlightRequest
		{
			ScopeType = "page",
			Style = "wash",
			DurationMs = 320
		});
	}

	private void TriggerSectionHighlight(string? sectionKey, string style = "glow")
	{
		if (string.IsNullOrWhiteSpace(sectionKey))
		{
			TriggerPageHighlight();
			return;
		}
		var normalized = NormalizeHighlightId(sectionKey);
		if (string.IsNullOrWhiteSpace(normalized))
		{
			TriggerPageHighlight();
			return;
		}
		HighlightService.Trigger(new HighlightRequest
		{
			ScopeType = "section",
			Id = normalized,
			Style = style,
			DurationMs = 320
		});
	}

	private void TriggerSlotHighlight(string slotId, string style = "glow")
	{
		if (string.IsNullOrWhiteSpace(slotId))
		{
			return;
		}
		HighlightService.Trigger(new HighlightRequest
		{
			ScopeType = "slot",
			Id = slotId,
			Style = style,
			DurationMs = 320
		});
	}

	private static string NormalizeHighlightId(string? key)
	{
		if (string.IsNullOrWhiteSpace(key))
		{
			return string.Empty;
		}
		return Regex.Replace(key.Trim().ToLowerInvariant(), "[^a-z0-9]", string.Empty);
	}

	// 動作確認メモ:
	// - 背景変更でページ全体(wash)が点灯する
	// - フレーム変更で選択セクション(glow)が点灯する
	// - 帯変更でヘッダー帯(outline)のみ点灯する
	// - タブ変更でタブ領域(glow)のみ点灯する
	// - 連続操作でも過剰に点滅せず追従する
	// - セクション切替/プレビュー再描画後もハイライトが機能する

	private async Task ScrollPreviewToSectionAsync(string sectionKey)
	{
		if (string.IsNullOrWhiteSpace(sectionKey))
		{
			return;
		}
		await JS.InvokeVoidAsync("lpHighlight.scrollToSection", "previewFrame", sectionKey);
	}

	private async Task OnSectionRowSelectedAsync(SectionGroupModel group)
	{
		if (group is null || string.IsNullOrWhiteSpace(group.Key))
		{
			return;
		}

		SelectedSectionId = group.Key;
		await ScrollPreviewToSectionAsync(group.Key);
		await TriggerHighlightAsync(group.Key, "section");
	}

	private async Task OnMiniMapSelectAsync(string key)
	{
		if (string.IsNullOrWhiteSpace(key))
		{
			return;
		}
		SelectedSectionId = key;
		await ScrollPreviewToSectionAsync(key);
	}

	private async Task OnSectionVisibilityChanged(SectionGroupModel group, ChangeEventArgs e)
	{
		if (group is null)
		{
			return;
		}

		if (e?.Value is bool isVisible)
		{
			group.Enabled = isVisible;
		}
		else if (bool.TryParse(e?.Value?.ToString(), out var parsed))
		{
			group.Enabled = parsed;
		}

		await OnSectionGroupChanged();
	}

	private IReadOnlyList<MiniMap.MiniMapSection> GetMiniMapSections()
	{
		return SectionGroupsSafe
			.Where(group => IsEditorManagedSectionKey(group.Key))
			.Select(group => new MiniMap.MiniMapSection
			{
				Key = group.Key ?? string.Empty,
				NormalizedKey = NormalizeSectionKey(group.Key),
				Title = GetSectionDisplayName(group.Key, group.DisplayName),
				IsEnabled = group.Enabled
			})
			.ToList();
	}

	private static string GetSectionIcon(string? key, bool isCustom)
	{
		if (isCustom)
		{
			return "🧩";
		}
		return NormalizeSectionKey(key) switch
		{
			"campaigncontent" => "📝",
			"couponperiod" => "📅",
			"couponflow" => "🧭",
			"couponnotes" => "🧾",
			"stickytabs" => "📌",
			"ranking" => "🏆",
			"paymenthistory" => "💳",
			"countdown" => "⏱",
			"storesearch" => "🔎",
			_ => "📦"
		};
	}

	private static string GetSectionIconLabel(string? key, bool isCustom)
	{
		if (isCustom)
		{
			return "カスタムセクション";
		}
		return NormalizeSectionKey(key) switch
		{
			"campaigncontent" => "キャンペーン内容",
			"couponperiod" => "クーポン期間",
			"couponflow" => "クーポン導線",
			"couponnotes" => "クーポン注意事項",
			"stickytabs" => "タブセクション",
			"ranking" => "ランキング",
			"paymenthistory" => "決済履歴",
			"countdown" => "カウントダウン",
			"storesearch" => "店舗検索",
			_ => "セクション"
		};
	}

	private string GetSectionSubInfo(SectionGroupModel group)
	{
		if (string.IsNullOrWhiteSpace(group.Key))
		{
			return string.Empty;
		}
		var isCustom = CustomSectionsSafe.Any(section => string.Equals(section.Key, group.Key, StringComparison.OrdinalIgnoreCase));
		var typeLabel = GetSectionTypeLabel(group.Key, isCustom);
		var visibility = group.Enabled ? "表示中" : "非表示";
		return $"{typeLabel} · {visibility}";
	}

	private IEnumerable<SectionGroupModel> GetFilteredSectionGroups()
	{
		IEnumerable<SectionGroupModel> query = SectionGroupsSafe
			.Where(group => IsEditorManagedSectionKey(group.Key));

		if (!string.IsNullOrWhiteSpace(SectionSearch))
		{
			var keyword = SectionSearch.Trim();
			query = query.Where(group =>
				GetSectionDisplayName(group.Key, group.DisplayName).Contains(keyword, StringComparison.OrdinalIgnoreCase)
				|| (group.Key?.Contains(keyword, StringComparison.OrdinalIgnoreCase) ?? false));
		}

		switch (SectionVisibilityFilter)
		{
			case "visible":
				query = query.Where(group => group.Enabled);
				break;
			case "hidden":
				query = query.Where(group => !group.Enabled);
				break;
		}

		if (!string.Equals(SectionTypeFilter, "all", StringComparison.OrdinalIgnoreCase))
		{
			query = query.Where(group =>
			{
				var isCustom = CustomSectionsSafe.Any(section => string.Equals(section.Key, group.Key, StringComparison.OrdinalIgnoreCase));
				return string.Equals(GetSectionTypeKey(group.Key, isCustom), SectionTypeFilter, StringComparison.OrdinalIgnoreCase);
			});
		}

		return query;
	}

	private IReadOnlyList<SectionGroupModel> FilteredSectionGroups
		=> GetFilteredSectionGroups().ToList();

	private IReadOnlyList<SectionGroupModel> SectionGroupsSafe
		=> State.Content.SectionGroups ?? new List<SectionGroupModel>();

	private IReadOnlyList<CustomSectionModel> CustomSectionsSafe
		=> State.Content.CustomSections ?? new List<CustomSectionModel>();

	private IReadOnlyList<KeyValuePair<string, string>> GetSectionTypeOptions()
	{
		var order = new[] { "campaign", "coupon", "tabs", "ranking", "payment", "countdown", "store", "custom", "other" };
		var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
		foreach (var group in SectionGroupsSafe.Where(group => IsEditorManagedSectionKey(group.Key)))
		{
			var isCustom = CustomSectionsSafe.Any(section => string.Equals(section.Key, group.Key, StringComparison.OrdinalIgnoreCase));
			var key = GetSectionTypeKey(group.Key, isCustom);
			if (!map.ContainsKey(key))
			{
				map[key] = GetSectionTypeLabel(group.Key, isCustom);
			}
		}
		return order.Where(map.ContainsKey)
			.Select(key => new KeyValuePair<string, string>(key, map[key]))
			.ToList();
	}

	private static string GetSectionTypeKey(string? key, bool isCustom)
	{
		if (isCustom)
		{
			return "custom";
		}
		return NormalizeSectionKey(key) switch
		{
			"campaigncontent" => "campaign",
			"couponperiod" => "coupon",
			"couponflow" => "coupon",
			"couponnotes" => "coupon",
			"stickytabs" => "tabs",
			"ranking" => "ranking",
			"paymenthistory" => "payment",
			"countdown" => "countdown",
			"storesearch" => "store",
			_ => "other"
		};
	}

	private static string GetSectionTypeLabel(string? key, bool isCustom)
	{
		if (isCustom)
		{
			return "カスタム";
		}
		return NormalizeSectionKey(key) switch
		{
			"campaigncontent" => "キャンペーン",
			"couponperiod" => "クーポン",
			"couponflow" => "クーポン",
			"couponnotes" => "クーポン",
			"stickytabs" => "タブ",
			"ranking" => "ランキング",
			"paymenthistory" => "決済履歴",
			"countdown" => "カウントダウン",
			"storesearch" => "店舗検索",
			_ => "その他"
		};
	}

	private static string GetSectionRowId(string normalizedKey)
		=> string.IsNullOrWhiteSpace(normalizedKey) ? string.Empty : $"section-row-{normalizedKey}";

	private async Task OnSectionEditClickedAsync(SectionGroupModel group, string openKey)
	{
		if (group is null || string.IsNullOrWhiteSpace(group.Key))
		{
			return;
		}

		SelectedSectionId = group.Key;
		if (IsSectionOpen(openKey))
		{
			ToggleSection(openKey);
		}
		else
		{
			OpenSection(openKey);
		}
		SetTab("content");
		await ScrollToEditorAsync($"[data-id='{group.Key}']");
		await ScrollPreviewToSectionAsync(group.Key);
		await TriggerHighlightAsync(group.Key, "section");
	}

	private async Task OnSectionMenuActionAsync(SectionGroupModel group, string action)
	{
		if (group is null)
		{
			return;
		}
		switch (action)
		{
			case "delete":
				await RemoveSectionGroupAsync(group.Key ?? string.Empty);
				break;
		}
	}

	private async Task ScrollToEditorAsync(string selector)
	{
		await JS.InvokeVoidAsync("lpHighlight.scrollToEditor", selector);
	}

	private async Task TogglePreviewModeAsync()
	{
		PreviewMode = PreviewMode == "final" ? "edit" : "final";
		await JS.InvokeVoidAsync("lpHighlight.setPreviewMode", "previewFrame", PreviewMode);
	}

	private async Task OnSectionRowActionAsync(SectionGroupModel group, string action)
	{
		SelectedSectionId = group.Key ?? string.Empty;
		OpenSection($"group-{group.Key}");
		await ScrollToEditorAsync($"[data-id='{group.Key}']");
		switch (action)
		{
			case "scroll":
				await ScrollPreviewToSectionAsync(group.Key ?? string.Empty);
				await TriggerHighlightAsync(group.Key ?? string.Empty, "section");
				break;
			case "text":
				SetTab("content");
				await ScrollPreviewToSectionAsync(group.Key ?? string.Empty);
				await TriggerHighlightAsync(group.Key ?? string.Empty, "section");
				break;
			case "decor":
				SetTab("content");
				await ScrollPreviewToSectionAsync(group.Key ?? string.Empty);
				await TriggerHighlightAsync(group.Key ?? string.Empty, "decor");
				break;
			case "background":
				SetTab("design");
				await TriggerHighlightAsync(group.Key ?? string.Empty, "background");
				break;
			case "toggle":
				group.Enabled = !group.Enabled;
				await OnSectionGroupChanged();
				break;
		}
	}

	private IReadOnlyList<SafetyIssue> GetSafetyIssues()
	{
		if (IsImportMode)
		{
			return Array.Empty<SafetyIssue>();
		}
		var issues = new List<SafetyIssue>();
		if (string.IsNullOrWhiteSpace(State.Content.Meta.PageTitle))
		{
			issues.Add(new SafetyIssue { Id = "title", Message = "ページタイトルが未入力", ActionLabel = "タイトルへ移動", TargetTab = "content" });
		}
		if (string.IsNullOrWhiteSpace(State.Content.Sections.CampaignContent.Title))
		{
			issues.Add(new SafetyIssue { Id = "campaign-title", Message = "セクションタイトルが未入力", ActionLabel = "セクションへ移動", TargetTab = "content", TargetSection = "campaign-content" });
		}
		if (State.Content.Sections.CampaignContent.Notes.Any(item => item.FontSize.HasValue && item.FontSize.Value < 12))
		{
			issues.Add(new SafetyIssue { Id = "font-small", Message = "文字サイズが小さすぎます（12px未満）", ActionLabel = "該当セクションへ", TargetTab = "content", TargetSection = "campaign-content" });
		}
		if (!string.IsNullOrWhiteSpace(State.Content.CampaignStyle.TextColor)
			&& !string.IsNullOrWhiteSpace(State.Content.CampaignStyle.BoxColor)
			&& IsLowContrast(State.Content.CampaignStyle.TextColor, State.Content.CampaignStyle.BoxColor))
		{
			issues.Add(new SafetyIssue { Id = "contrast", Message = "文字色と背景色のコントラストが低い可能性があります", ActionLabel = "色設定へ", TargetTab = "content" });
		}
		if (State.Content.SectionStyles.Any(kv => (kv.Value?.Decorations?.Count ?? 0) > 4))
		{
			issues.Add(new SafetyIssue { Id = "decor-too-many", Message = "装飾が多すぎるセクションがあります（5件以上）", ActionLabel = "セクションへ", TargetTab = "content" });
		}
		if (State.Content.Campaign.StartDate.Contains("YYYY", StringComparison.OrdinalIgnoreCase)
			|| State.Content.Campaign.EndDate.Contains("YYYY", StringComparison.OrdinalIgnoreCase))
		{
			issues.Add(new SafetyIssue { Id = "placeholder", Message = "日付が未入力のままです（YYYY）", ActionLabel = "基本タブへ", TargetTab = "basic" });
		}
		if (State.Content.Sections.CampaignContent.Notes.Count > 8)
		{
			issues.Add(new SafetyIssue { Id = "decor-count", Message = "装飾や注意事項が多すぎます（8行超）", ActionLabel = "確認", TargetTab = "content", TargetSection = "campaign-content" });
		}
		return issues;
	}

	private static bool IsLowContrast(string foreground, string background)
	{
		var fg = ParseColor(foreground);
		var bg = ParseColor(background);
		if (fg is null || bg is null)
		{
			return false;
		}
		var diff = Math.Abs(fg.Value.L - bg.Value.L);
		return diff < 0.35;
	}

	private static (double L, bool Ok)? ParseColor(string value)
	{
		if (string.IsNullOrWhiteSpace(value) || !value.StartsWith("#"))
		{
			return null;
		}
		var hex = value.TrimStart('#');
		if (hex.Length == 3)
		{
			hex = string.Concat(hex.Select(c => new string(c, 2)));
		}
		if (hex.Length != 6)
		{
			return null;
		}
		if (!int.TryParse(hex.Substring(0, 2), System.Globalization.NumberStyles.HexNumber, null, out var r)
			|| !int.TryParse(hex.Substring(2, 2), System.Globalization.NumberStyles.HexNumber, null, out var g)
			|| !int.TryParse(hex.Substring(4, 2), System.Globalization.NumberStyles.HexNumber, null, out var b))
		{
			return null;
		}
		var lr = r / 255d;
		var lg = g / 255d;
		var lb = b / 255d;
		var l = 0.2126 * lr + 0.7152 * lg + 0.0722 * lb;
		return (l, true);
	}

	private async Task OnSafetyFixRequested(SafetyIssue issue)
	{
		if (!string.IsNullOrWhiteSpace(issue.TargetTab))
		{
			SetTab(issue.TargetTab);
		}
		if (!string.IsNullOrWhiteSpace(issue.TargetSection))
		{
			SelectedSectionId = issue.TargetSection;
			await ScrollPreviewToSectionAsync(issue.TargetSection);
		}
	}

	private static string GetSectionDisplayName(string? key, string? displayName = null)
	{
		if (string.IsNullOrWhiteSpace(key))
		{
			return "-";
		}

		if (!string.IsNullOrWhiteSpace(displayName))
		{
			return displayName;
		}

		if (key.StartsWith("custom-section", StringComparison.OrdinalIgnoreCase))
		{
			return "通常セクション";
		}
		if (key.StartsWith("store-search", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "storeSearch", StringComparison.OrdinalIgnoreCase))
		{
			return "店舗検索";
		}
		if (key.Contains("conditions-contact-banners", StringComparison.OrdinalIgnoreCase))
		{
			return "条件・お問い合わせ・バナー";
		}
		if (key.Contains("banner", StringComparison.OrdinalIgnoreCase))
		{
			return "バナー";
		}

		if (string.Equals(key, "payment-history", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "paymentHistory", StringComparison.OrdinalIgnoreCase))
		{
			return "決済履歴の確認方法";
		}
		if (string.Equals(key, "campaign-content", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "campaignContent", StringComparison.OrdinalIgnoreCase))
		{
			return "キャンペーン内容";
		}
		if (string.Equals(key, "coupon-period", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "couponPeriod", StringComparison.OrdinalIgnoreCase))
		{
			return "キャンペーン期間";
		}
		if (string.Equals(key, "coupon-flow", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "couponFlow", StringComparison.OrdinalIgnoreCase))
		{
			return "クーポン利用方法";
		}
		if (string.Equals(key, "sticky-tabs", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "stickyTabs", StringComparison.OrdinalIgnoreCase))
		{
			return "付箋タブ（注意事項/特典/FAQ）";
		}
		if (string.Equals(key, "coupon-notes", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "couponNotes", StringComparison.OrdinalIgnoreCase))
		{
			return "注意事項";
		}
		if (string.Equals(key, "ranking", StringComparison.OrdinalIgnoreCase))
		{
			return "ランキング";
		}
		if (string.Equals(key, "conditions", StringComparison.OrdinalIgnoreCase))
		{
			return "利用条件";
		}
		if (string.Equals(key, "contact", StringComparison.OrdinalIgnoreCase))
		{
			return "お問い合わせ";
		}

		return string.Equals(key, "countdown", StringComparison.OrdinalIgnoreCase)
			? "フッター"
			: key;
	}

	private string? GetSectionGroupDisplayName(string? key)
	{
		if (string.IsNullOrWhiteSpace(key))
		{
			return null;
		}

		return SectionGroupsSafe
			.FirstOrDefault(group => string.Equals(group.Key, key, StringComparison.OrdinalIgnoreCase))
			?.DisplayName;
	}

	private bool IsEditorManagedSectionKey(string? key)
	{
		if (string.IsNullOrWhiteSpace(key))
		{
			return false;
		}

		if (CustomSectionsSafe.Any(section => string.Equals(section.Key, key, StringComparison.OrdinalIgnoreCase)))
		{
			return true;
		}

		return NormalizeSectionKey(key) switch
		{
			"campaigncontent" => true,
			"couponperiod" => true,
			"couponflow" => true,
			"couponnotes" => true,
			"stickytabs" => true,
			"ranking" => true,
			"paymenthistory" => true,
			"countdown" => true,
			"storesearch" => true,
			_ => false
		};
	}

	private static string NormalizeSectionKey(string? key)
	{
		if (string.IsNullOrWhiteSpace(key))
		{
			return string.Empty;
		}

		return Regex.Replace(key.Trim().ToLowerInvariant(), "[^a-z0-9]", string.Empty);
	}


	private async Task OnTemplateZipSelected(InputFileChangeEventArgs e)
	{
		State.Error.Clear();
		try
		{
			ImportSession = null;
			ImportProject = null;
			ImportEntryHtmlPath = null;
			var file = e.File;
			if (file is null)
			{
				return;
			}

			var tempPath = Path.Combine(Path.GetTempPath(), $"lp-template-{Guid.NewGuid()}.zip");
			await using (var stream = File.Create(tempPath))
			{
				await file.OpenReadStream(long.MaxValue).CopyToAsync(stream);
			}

			State.Template = await TemplateService.LoadTemplateAsync(tempPath);
			State.Content = State.Template.CurrentContent;
			TemplateTextFontSize = null;
			State.TemplateName = Path.GetFileName(file.Name);
			State.TemplateLoadedAt = DateTime.Now;
			CategorizeImages(State.Template);
			BuildImageMeta(State.Template);
			EnsureCouponPeriodDefaults();
			ResetSectionTextLines();
			EnsureSectionTextLines();
			EnsureSectionSelection();
			EnsureFrameDefaultStyle();
			CleanFrameOverrideData();
			SyncPageBackgroundSetting();
			SetupEditContext();
			await UpdatePreviewAsync();
		}
		catch (Exception ex)
		{
			State.Error.SetError("テンプレート読み込みに失敗", ex.Message);
		}
	}

	private async Task OnImportZipSelected(InputFileChangeEventArgs e)
	{
		State.Error.Clear();
		try
		{
			var file = e.File;
			if (file is null)
			{
				return;
			}

			IsImporting = true;
			ImportStage = "解凍中...";
			ImportProject = null;
			SelectedImportSectionId = string.Empty;

			var tempPath = Path.Combine(Path.GetTempPath(), $"lp-import-{Guid.NewGuid()}.zip");
			await using (var stream = File.Create(tempPath))
			{
				await file.OpenReadStream(long.MaxValue).CopyToAsync(stream);
			}

			ImportSession = await LpImportService.LoadZipAsync(tempPath);
			if (ImportSession.HtmlEntries.Count == 0)
			{
				State.Error.SetError("HTMLが見つかりません", "ZIP内にHTMLファイルがありません。");
				return;
			}

			ImportEntryHtmlPath = ImportSession.HtmlEntries
				.FirstOrDefault(path => path.EndsWith("index.html", StringComparison.OrdinalIgnoreCase))
				?? ImportSession.HtmlEntries.FirstOrDefault();
			ImportStage = $"HTML {ImportSession.HtmlEntries.Count}件 検出";
			IsImporting = false;
		}
		catch (Exception ex)
		{
			State.Error.SetError("取り込みに失敗", ex.Message);
		}
		finally
		{
			IsImporting = false;
		}
	}

	private async Task AnalyzeImportAsync()
	{
		if (ImportSession is null)
		{
			return;
		}
		if (string.IsNullOrWhiteSpace(ImportEntryHtmlPath))
		{
			ImportEntryHtmlPath = ImportSession.HtmlEntries.FirstOrDefault();
		}
		if (string.IsNullOrWhiteSpace(ImportEntryHtmlPath))
		{
			State.Error.SetError("HTMLが見つかりません", "ZIP内にHTMLがありません。");
			return;
		}

		State.Error.Clear();
		IsImporting = true;
		try
		{
			ImportStage = "解析中...";
			ImportProject = await LpImportService.AnalyzeAsync(ImportSession, ImportEntryHtmlPath);
			SelectedImportSectionId = ImportProject.Sections.FirstOrDefault()?.Id ?? string.Empty;
			ImportStage = "モデル生成完了";
			await UpdatePreviewAsync();
		}
		catch (Exception ex)
		{
			State.Error.SetError("解析に失敗", ex.Message);
		}
		finally
		{
			IsImporting = false;
		}
	}

	private void StartImportEditing()
	{
		SetTab("content");
	}

	private void SelectImportSection(string sectionId)
	{
		SelectedImportSectionId = sectionId;
	}

	private bool IsSelectedImportSection(LpImportSection section)
	{
		return string.Equals(section.Id, SelectedImportSectionId, StringComparison.OrdinalIgnoreCase);
	}

	private async Task OnImportInputAsync()
	{
		await UpdatePreviewAsync();
	}

	private async Task OnImportImageUrlChanged(LpImportBlock block)
	{
		if (ImportProject is null)
		{
			return;
		}

		block.Src = block.Src?.Trim() ?? string.Empty;
		if (IsExternalUrl(block.Src))
		{
			block.AssetRef = new LpImportAssetRef
			{
				Path = block.Src,
				IsExternal = true,
				MimeType = string.Empty
			};
		}
		else
		{
			var resolved = ResolveImportPath(block.Src);
			block.AssetRef = new LpImportAssetRef
			{
				Path = resolved,
				IsExternal = false,
				MimeType = GuessMimeType(resolved)
			};
		}
		await UpdatePreviewAsync();
	}

	private async Task OnImportImageFileSelected(InputFileChangeEventArgs e, LpImportBlock block)
	{
		if (ImportProject is null)
		{
			return;
		}

		State.Error.Clear();
		try
		{
			var file = e.File;
			if (file is null)
			{
				return;
			}

			using var ms = new MemoryStream();
			await file.OpenReadStream(long.MaxValue).CopyToAsync(ms);
			var bytes = ms.ToArray();
			var ext = Path.GetExtension(file.Name);
			if (!IsExternalUrl(block.Src))
			{
				var resolved = ResolveImportPath(block.Src);
				if (!string.IsNullOrWhiteSpace(resolved) && ImportProject.Files.ContainsKey(resolved))
				{
					ImportProject.AssetOverrides[resolved] = bytes;
					block.Src = resolved;
					block.AssetRef = new LpImportAssetRef
					{
						Path = resolved,
						IsExternal = false,
						MimeType = GuessMimeType(resolved)
					};
					await UpdatePreviewAsync();
					return;
				}
			}

			var assetPath = $"assets/imported/{Guid.NewGuid()}{ext}";
			ImportProject.NewAssets[assetPath] = bytes;
			block.Src = assetPath;
			block.AssetRef = new LpImportAssetRef
			{
				Path = assetPath,
				IsExternal = false,
				MimeType = GuessMimeType(assetPath)
			};

			await UpdatePreviewAsync();
		}
		catch (Exception ex)
		{
			State.Error.SetError("画像差し替えに失敗", ex.Message);
		}
	}

	private string GetImportImagePreview(LpImportBlock block)
	{
		if (ImportProject is null)
		{
			return string.Empty;
		}

		if (IsExternalUrl(block.Src) || block.Src.StartsWith("data:", StringComparison.OrdinalIgnoreCase))
		{
			return block.Src;
		}

		var resolved = ResolveImportPath(block.Src);
		if (ImportProject.AssetOverrides.TryGetValue(resolved, out var overrideBytes))
		{
			return ToDataUrl(overrideBytes, resolved);
		}
		if (ImportProject.NewAssets.TryGetValue(resolved, out var newBytes))
		{
			return ToDataUrl(newBytes, resolved);
		}
		if (ImportProject.Files.TryGetValue(resolved, out var file))
		{
			return ToDataUrl(file.Data, resolved);
		}

		return block.Src;
	}

	private string ResolveImportPath(string rawPath)
	{
		if (string.IsNullOrWhiteSpace(rawPath))
		{
			return string.Empty;
		}

		var clean = rawPath.Split('#')[0].Split('?')[0];
		if (string.IsNullOrWhiteSpace(clean))
		{
			return string.Empty;
		}

		if (clean.StartsWith("/", StringComparison.Ordinal))
		{
			return clean.TrimStart('/');
		}

		var baseDir = GetImportBaseDirectory();
		if (string.IsNullOrWhiteSpace(baseDir))
		{
			return clean;
		}

		var baseUri = new Uri($"file:///{baseDir}");
		var resolved = new Uri(baseUri, clean);
		return resolved.AbsolutePath.TrimStart('/');
	}

	private string GetImportBaseDirectory()
	{
		var entry = ImportEntryHtmlPath ?? ImportProject?.EntryHtmlPath ?? string.Empty;
		if (string.IsNullOrWhiteSpace(entry))
		{
			return string.Empty;
		}

		var normalized = entry.Replace("\\", "/");
		var lastSlash = normalized.LastIndexOf('/');
		if (lastSlash <= 0)
		{
			return string.Empty;
		}
		return normalized[..(lastSlash + 1)];
	}

	private static bool IsExternalUrl(string url)
	{
		if (url.StartsWith("//", StringComparison.Ordinal))
		{
			return true;
		}

		return url.StartsWith("http://", StringComparison.OrdinalIgnoreCase)
			|| url.StartsWith("https://", StringComparison.OrdinalIgnoreCase)
			|| url.StartsWith("data:", StringComparison.OrdinalIgnoreCase)
			|| url.StartsWith("mailto:", StringComparison.OrdinalIgnoreCase)
			|| url.StartsWith("tel:", StringComparison.OrdinalIgnoreCase);
	}

	private static string GuessMimeType(string path)
	{
		var ext = Path.GetExtension(path).TrimStart('.').ToLowerInvariant();
		return ext switch
		{
			"jpg" or "jpeg" => "image/jpeg",
			"png" => "image/png",
			"gif" => "image/gif",
			"webp" => "image/webp",
			"svg" => "image/svg+xml",
			_ => "application/octet-stream"
		};
	}

	private void CategorizeImages(TemplateProject template)
	{
		var all = GetImagePaths(template);
		State.BackgroundImagePaths = all.Where(IsBackgroundImage).ToList();
		State.DecoImagePaths = all.Where(IsDecoImage).ToList();
		var classified = new HashSet<string>(State.BackgroundImagePaths.Concat(State.DecoImagePaths), StringComparer.OrdinalIgnoreCase);
		State.OtherImagePaths = all.Where(path => !classified.Contains(path)).ToList();
	}

	private static bool IsBackgroundImage(string path)
	{
		var lower = path.ToLowerInvariant();
		return lower.Contains("/background/")
			|| lower.Contains("/bg/")
			|| lower.Contains("background")
			|| lower.Contains("_bg")
			|| lower.Contains("bg_");
	}

	private static bool IsDecoImage(string path)
	{
		var lower = path.ToLowerInvariant();
		return lower.Contains("/deco/")
			|| lower.Contains("/decoration/")
			|| lower.Contains("deco")
			|| lower.Contains("ornament")
			|| lower.Contains("flower")
			|| lower.Contains("pattern");
	}

	private static List<string> GetImagePaths(TemplateProject template)
	{
		return template.Files.Values
			.Where(file => file.IsImage)
			.Select(file => file.RelativePath)
			.OrderBy(path => path, StringComparer.OrdinalIgnoreCase)
			.ToList();
	}

	private async Task OnContentJsonSelected(InputFileChangeEventArgs e)
	{
		State.Error.Clear();
		try
		{
			var file = e.File;
			if (file is null)
			{
				return;
			}

			using var reader = new StreamReader(file.OpenReadStream(long.MaxValue));
			var json = await reader.ReadToEndAsync();
			State.Content = JsonSerializer.Deserialize<ContentModel>(json) ?? new ContentModel();
			EnsureContentCollections();
			if (State.Template is not null && State.Template.SectionGroupKeys.Count > 0)
			{
				TemplateService.EnsureSectionGroups(State.Content, State.Template.SectionGroupKeys);
			}
			ApplyDefaultFontSizeToAllItems();
			EnsureCouponPeriodDefaults();
			EnsureSectionSelection();
			EnsureFrameDefaultStyle();
			CleanFrameOverrideData();
			SyncPageBackgroundSetting();
			SetupEditContext();
			await UpdatePreviewAsync();
		}
		catch (Exception ex)
		{
			State.Error.SetError("content.json読み込みに失敗", ex.Message);
		}
	}

	private void EnsureContentCollections()
	{
		State.Content.SectionGroups ??= new List<SectionGroupModel>();
		State.Content.CustomSections ??= new List<CustomSectionModel>();
		State.Content.Sections ??= new SectionsModel();
	}

	private async Task OnSaveContent()
	{
		State.Error.Clear();
		try
		{
			await SaveCurrentContentAsync();
		}
		catch (Exception ex)
		{
			State.Error.SetError("content.json保存に失敗", ex.Message);
		}
	}

	private async Task OnExportZip()
	{
		State.Error.Clear();
		try
		{
			if (IsImportMode && ImportProject is not null)
			{
				var importZipBytes = await LpImportService.ExportBytesAsync(ImportProject);
				await SaveZipToUserAsync(importZipBytes);
				return;
			}

			if (State.Template is null)
			{
				State.Error.SetError("テンプレート未読み込み", "テンプレートZIPを先に読み込んでください");
				return;
			}

			var issues = GetValidationIssues();
			if (issues.Count > 0)
			{
				State.Error.SetError("入力不足", string.Join(" / ", issues));
				return;
			}

			await SaveCurrentContentAsync();
			var zipBytes = await ZipExportService.ExportBytesAsync(State.Template, State.Content, State.ImageOverrides);
			await SaveZipToUserAsync(zipBytes);
		}
		catch (Exception ex)
		{
			State.Error.SetError("ZIP出力に失敗", ex.Message);
		}
	}

	private async Task SaveCurrentContentAsync()
	{
		if (string.IsNullOrWhiteSpace(ContentSavePath))
		{
			throw new InvalidOperationException("content.json 保存パスが未設定です。");
		}

		await ContentPersistService.SaveAsync(ContentSavePath, State.Content);
	}

	private async Task SaveZipToUserAsync(byte[] zipBytes)
	{
		var suggestedName = GetSuggestedZipName();
		await JS.InvokeVoidAsync("lpExport.saveZip", suggestedName, zipBytes);
	}

	private string GetSuggestedZipName()
	{
		var name = Path.GetFileName(OutputZipPath ?? string.Empty);
		return string.IsNullOrWhiteSpace(name) ? "lp-output.zip" : name;
	}

	private async Task OnImageSelected(InputFileChangeEventArgs e, string targetPath)
	{
		State.Error.Clear();
		try
		{
			var file = e.File;
			if (file is null)
			{
				return;
			}

			using var ms = new MemoryStream();
			await file.OpenReadStream(long.MaxValue).CopyToAsync(ms);
			var bytes = ms.ToArray();
			var ext = Path.GetExtension(file.Name).ToLowerInvariant();
			if (ext == ".png")
			{
				var maxWidth = GetMaxWidth(targetPath);
				var resized = await ImageService.ResizePngAsync(bytes, maxWidth);
				State.ImageOverrides[targetPath] = resized;
				UpdateImageMeta(targetPath, resized);
			}
			else
			{
				State.ImageOverrides[targetPath] = bytes;
				UpdateImageMeta(targetPath, bytes);
			}

			RemoveDeletedImage(targetPath);
			await UpdatePreviewAsync();
		}
		catch (Exception ex)
		{
			State.Error.SetError("画像処理に失敗", ex.Message);
		}
	}

	private async Task SaveCustomSectionImageAsync(string path, byte[] bytes)
	{
		if (string.IsNullOrWhiteSpace(path))
		{
			return;
		}

		var ext = Path.GetExtension(path).ToLowerInvariant();
		if (ext == ".png")
		{
			var maxWidth = GetMaxWidth(path);
			var resized = await ImageService.ResizePngAsync(bytes, maxWidth);
			State.ImageOverrides[path] = resized;
			UpdateImageMeta(path, resized);
		}
		else
		{
			State.ImageOverrides[path] = bytes;
			UpdateImageMeta(path, bytes);
		}

		RemoveDeletedImage(path);
	}

	private async Task OnEndDateChanged()
	{
		var value = State.Content.Campaign.EndDate ?? string.Empty;
		if (!string.IsNullOrWhiteSpace(value))
		{
			State.Content.Campaign.CountdownEnd = $"{value}T23:59:59";
		}

		await UpdatePreviewAsync();
	}

	private async Task OnCampaignDateChanged()
	{
		var value = State.Content.Campaign.EndDate ?? string.Empty;
		if (!string.IsNullOrWhiteSpace(value))
		{
			State.Content.Campaign.CountdownEnd = $"{value}T23:59:59";
		}

		EnsureCouponPeriodDefaults();

		await UpdatePreviewAsync();
	}

	private async Task OnCampaignStartChanged(ChangeEventArgs e)
	{
		State.Content.Campaign.StartDate = NormalizeDate(e?.Value?.ToString());
		await OnCampaignDateChanged();
	}

	private async Task OnCampaignEndChanged(ChangeEventArgs e)
	{
		State.Content.Campaign.EndDate = NormalizeDate(e?.Value?.ToString());
		await OnCampaignDateChanged();
	}

	private async Task OnCouponPeriodStartChanged(ChangeEventArgs e)
	{
		State.Content.Sections.CouponPeriod.StartDate = NormalizeDate(e?.Value?.ToString());
		await OnCouponPeriodDateChanged();
	}

	private async Task OnCouponPeriodEndChanged(ChangeEventArgs e)
	{
		State.Content.Sections.CouponPeriod.EndDate = NormalizeDate(e?.Value?.ToString());
		await OnCouponPeriodDateChanged();
	}

	private async Task OnCouponPeriodTextSizeChanged(ChangeEventArgs e)
	{
		var value = e?.Value?.ToString();
		if (int.TryParse(value, out var size))
		{
			State.Content.Sections.CouponPeriod.TextFontSize = size;
		}
		else
		{
			State.Content.Sections.CouponPeriod.TextFontSize = null;
		}

		await UpdatePreviewAsync();
	}

	private async Task OnCountdownEndInputChanged(ChangeEventArgs e)
	{
		State.Content.Campaign.CountdownEnd = NormalizeDateTimeLocal(e?.Value?.ToString());
		await UpdatePreviewAsync();
	}

	private async Task OnCountdownTextSizeChanged(ChangeEventArgs e)
	{
		var value = e?.Value?.ToString();
		if (int.TryParse(value, out var size))
		{
			State.Content.Campaign.CountdownTextSize = size;
		}
		else
		{
			State.Content.Campaign.CountdownTextSize = null;
		}

		await UpdatePreviewAsync();
	}

	private async Task OnCouponPeriodDateChanged()
	{
		State.Content.Sections.CouponPeriod.Text = FormatDateRange(State.Content.Sections.CouponPeriod.StartDate, State.Content.Sections.CouponPeriod.EndDate);
		await UpdatePreviewAsync();
	}

	private async Task OnCouponPeriodModeChanged(ChangeEventArgs e)
	{
		var mode = e?.Value?.ToString() ?? "manual";
		State.Content.Sections.CouponPeriod.InputMode = mode;
		EnsureCouponPeriodDefaults();
		await UpdatePreviewAsync();
	}

	private void EnsureCouponPeriodDefaults()
	{
		var mode = State.Content.Sections.CouponPeriod.InputMode;
		if (string.IsNullOrWhiteSpace(mode))
		{
			State.Content.Sections.CouponPeriod.InputMode = "link";
			mode = "link";
		}
		else if (string.Equals(mode, "manual", StringComparison.OrdinalIgnoreCase)
			&& string.IsNullOrWhiteSpace(State.Content.Sections.CouponPeriod.Text))
		{
			State.Content.Sections.CouponPeriod.InputMode = "link";
			mode = "link";
		}

		if (string.Equals(mode, "link", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.CouponPeriod.Text = FormatDateRange(State.Content.Campaign.StartDate, State.Content.Campaign.EndDate);
		}
		else if (string.Equals(mode, "calendar", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.CouponPeriod.Text = FormatDateRange(State.Content.Sections.CouponPeriod.StartDate, State.Content.Sections.CouponPeriod.EndDate);
		}
	}

	private void ResetSectionTextLines()
	{
		_couponNotesLinesInitialized = false;
		_storeSearchNoticeLinesInitialized = false;
		_footerLinesInitialized = false;
		_customSectionLinesInitialized.Clear();
	}

	private void EnsureSectionTextLines()
	{
		EnsureCouponNotesTextLines();
		EnsureStoreSearchNoticeLines();
		EnsureFooterTextLines();
		EnsureCustomSectionTextLines();
	}

	private void EnsureCouponNotesTextLines()
	{
		if (_couponNotesLinesInitialized)
		{
			return;
		}

		var section = State.Content.Sections.CouponNotes;
		section.TextLines ??= new List<StyledTextItem>();
		if (section.TextLines.Count == 0 && section.Items.Count > 0)
		{
			// 旧 Items(TextItemModel) -> 新 TextLines(StyledTextItem)
			section.TextLines = MapTextItemsToStyledText(section.Items, section.FontFamily, section.TextAlign);
		}
		EnsureStyledTextIds(section.TextLines);
		_couponNotesLinesInitialized = true;
	}

	private void EnsureStoreSearchNoticeLines()
	{
		if (_storeSearchNoticeLinesInitialized)
		{
			return;
		}

		var section = State.Content.Sections.StoreSearch;
		section.NoticeLines ??= new List<StyledTextItem>();
		if (section.NoticeLines.Count == 0 && section.NoticeItems.Count > 0)
		{
			// 旧 NoticeItems(TextItemModel) -> 新 NoticeLines(StyledTextItem)
			section.NoticeLines = MapTextItemsToStyledText(section.NoticeItems, section.FontFamily, section.TextAlign);
		}
		EnsureStyledTextIds(section.NoticeLines);
		_storeSearchNoticeLinesInitialized = true;
	}

	private void EnsureFooterTextLines()
	{
		if (_footerLinesInitialized)
		{
			return;
		}
		State.Content.Campaign.FooterLines ??= new List<StyledTextItem>();
		if (State.Content.Campaign.FooterLines.Count == 0 && !string.IsNullOrWhiteSpace(State.Content.Campaign.EndedMessage))
		{
			// 旧 EndedMessage(単行) -> 新 FooterLines(StyledTextItem)
			State.Content.Campaign.FooterLines.Add(new StyledTextItem
			{
				Text = State.Content.Campaign.EndedMessage,
				Align = "center",
				Visible = true,
				Id = Guid.NewGuid()
			});
		}
		EnsureStyledTextIds(State.Content.Campaign.FooterLines);
		_footerLinesInitialized = true;
	}

	private void EnsureCustomSectionTextLines()
	{
		var sections = State.Content.CustomSections;
		if (sections is null)
		{
			return;
		}

		foreach (var section in sections)
		{
			if (string.IsNullOrWhiteSpace(section.Key))
			{
				continue;
			}

			if (_customSectionLinesInitialized.Contains(section.Key))
			{
				continue;
			}

			section.BodyTextItems ??= new List<StyledTextItem>();
			if (section.BodyTextItems.Count == 0 && !string.IsNullOrWhiteSpace(section.Body))
			{
				// 旧 Body(textarea) -> 新 BodyTextItems(StyledTextItem)
				section.BodyTextItems.Add(new StyledTextItem
				{
					Text = section.Body,
					Align = "left",
					Visible = true,
					FontFamily = section.FontFamily,
					Id = Guid.NewGuid()
				});
			}

			section.ImageNotesItems ??= new List<StyledTextItem>();
			if (section.ImageNotesItems.Count == 0 && !string.IsNullOrWhiteSpace(section.Notes))
			{
				// 旧 Notes(textarea) -> 新 ImageNotesItems(StyledTextItem)
				section.ImageNotesItems.Add(new StyledTextItem
				{
					Text = section.Notes,
					Align = "left",
					Visible = true,
					FontFamily = section.FontFamily,
					Id = Guid.NewGuid()
				});
			}

			EnsureStyledTextIds(section.BodyTextItems);
			EnsureStyledTextIds(section.ImageNotesItems);
			_customSectionLinesInitialized.Add(section.Key);
		}
	}

	private Task OnCouponNotesLinesChanged()
	{
		SyncCouponNotesLegacyItems();
		OnAnyInputAfter();
		return Task.CompletedTask;
	}

	private Task OnStoreSearchNoticeLinesChanged()
	{
		SyncStoreSearchLegacyItems();
		OnAnyInputAfter();
		return Task.CompletedTask;
	}

	private Task OnFooterLinesChanged()
	{
		OnAnyInputAfter();
		return Task.CompletedTask;
	}

	private Task OnCustomSectionLinesChanged()
	{
		OnAnyInputAfter();
		return Task.CompletedTask;
	}

	private void SyncCouponNotesLegacyItems()
	{
		var section = State.Content.Sections.CouponNotes;
		// 新 TextLines(StyledTextItem) -> 旧 Items(TextItemModel)
		section.Items = section.TextLines.Select(MapStyledTextToTextItem).ToList();
	}

	private void SyncStoreSearchLegacyItems()
	{
		var section = State.Content.Sections.StoreSearch;
		// 新 NoticeLines(StyledTextItem) -> 旧 NoticeItems(TextItemModel)
		section.NoticeItems = section.NoticeLines.Select(MapStyledTextToTextItem).ToList();
	}

	private static List<StyledTextItem> MapTextItemsToStyledText(IEnumerable<TextItemModel> items, string? fontFamily, string? align)
	{
		return items.Select(item => new StyledTextItem
		{
			Id = Guid.NewGuid(),
			Text = item.Text ?? string.Empty,
			Bold = item.Bold,
			Visible = true,
			FontSize = item.FontSize,
			Color = item.UseColor ? item.Color : null,
			FontFamily = fontFamily,
			Align = string.IsNullOrWhiteSpace(align) ? "left" : align
		}).ToList();
	}

	private static TextItemModel MapStyledTextToTextItem(StyledTextItem item)
	{
		return new TextItemModel
		{
			Text = item.Text ?? string.Empty,
			Emphasis = false,
			Bold = item.Bold,
			UseColor = !string.IsNullOrWhiteSpace(item.Color),
			Color = item.Color,
			FontSize = item.FontSize
		};
	}

	private static void EnsureStyledTextIds(List<StyledTextItem> items)
	{
		foreach (var item in items)
		{
			if (item.Id == Guid.Empty)
			{
				item.Id = Guid.NewGuid();
			}
		}
	}

	private static string FormatDateRange(string? startDate, string? endDate)
	{
		if (!DateTime.TryParse(startDate, out var start) || !DateTime.TryParse(endDate, out var end))
		{
			return string.Empty;
		}

		return $"{start:yyyy年M月d日}～{end:yyyy年M月d日}";
	}

	private string GetCouponPeriodPreviewText()
	{
		return State.Content.Sections.CouponPeriod.Text;
	}

	private static string NormalizeDate(string? value)
	{
		if (string.IsNullOrWhiteSpace(value))
		{
			return string.Empty;
		}

		return DateTime.TryParse(value, out var date)
			? date.ToString("yyyy-MM-dd")
			: value;
	}

	private static string NormalizeDateTimeLocal(string? value)
	{
		if (string.IsNullOrWhiteSpace(value))
		{
			return string.Empty;
		}

		if (DateTime.TryParse(value, out var dateTime))
		{
			return dateTime.ToString("yyyy-MM-ddTHH:mm:ss");
		}

		return value.Length == 16 ? $"{value}:00" : value;
	}

	private async void AddItem(List<TextItemModel> list)
	{
		var item = new TextItemModel();
		ApplyDefaultFontSize(item);
		list.Add(item);
		await UpdatePreviewAsync();
	}

	private async void RemoveItem(List<TextItemModel> list, TextItemModel item)
	{
		list.Remove(item);
		await UpdatePreviewAsync();
	}

	private static string GetColorValue(string? color)
	{
		return string.IsNullOrWhiteSpace(color) ? "#d32f2f" : color;
	}

	private async Task ToggleUseColor(TextItemModel item, ChangeEventArgs e)
	{
		var enabled = e?.Value is bool b && b;
		item.UseColor = enabled;
		if (enabled && string.IsNullOrWhiteSpace(item.Color))
		{
			item.Color = "#d32f2f";
		}
		await UpdatePreviewAsync();
	}

	private async Task ToggleUseColor(RankingTextItemModel item, ChangeEventArgs e)
	{
		var enabled = e?.Value is bool b && b;
		item.UseColor = enabled;
		if (enabled && string.IsNullOrWhiteSpace(item.Color))
		{
			item.Color = "#d32f2f";
		}
		await UpdatePreviewAsync();
	}

	private void ApplyDefaultFontSize(TextItemModel item)
	{
		if (item.FontSize is null && TemplateTextFontSize.HasValue)
		{
			item.FontSize = TemplateTextFontSize;
		}
	}

	private void ApplyDefaultFontSize(RankingTextItemModel item)
	{
		if (item.FontSize is null && TemplateTextFontSize.HasValue)
		{
			item.FontSize = TemplateTextFontSize;
		}
	}

	private void ApplyDefaultFontSizeToAllItems()
	{
		if (!TemplateTextFontSize.HasValue)
		{
			return;
		}

		foreach (var item in State.Content.Sections.CampaignContent.Notes)
		{
			ApplyDefaultFontSize(item);
		}
		foreach (var item in State.Content.Sections.StoreSearch.NoticeItems)
		{
			ApplyDefaultFontSize(item);
		}
		foreach (var item in State.Content.Sections.CouponNotes.Items)
		{
			ApplyDefaultFontSize(item);
		}
		foreach (var item in State.Content.Sections.Conditions.Items)
		{
			ApplyDefaultFontSize(item);
		}
		foreach (var item in State.Content.Sections.Ranking.Texts)
		{
			ApplyDefaultFontSize(item);
		}
	}

	private async void AddButton(List<ButtonItemModel> list)
	{
		list.Add(new ButtonItemModel());
		await UpdatePreviewAsync();
	}

	private async void RemoveButton(List<ButtonItemModel> list, ButtonItemModel item)
	{
		list.Remove(item);
		await UpdatePreviewAsync();
	}

	private async void AddRankingSection()
	{
		State.Content.Sections.Ranking.Enabled = true;
		EnsureSectionGroupKey("ranking", "couponNotes", "coupon-notes");
		MoveSectionGroupAfter("ranking", "couponNotes", "coupon-notes");
		EnsureRankingRefDefaults();
		await UpdatePreviewAsync();
	}

	private async void AddPaymentHistorySection()
	{
		State.Content.Sections.PaymentHistory.Enabled = true;
		EnsureSectionGroupKey("payment-history", "ranking");
		MoveSectionGroupAfter("payment-history", "ranking");
		EnsurePaymentHistoryDefaults();
		await UpdatePreviewAsync();
	}

	private async void AddCouponFlowSection()
	{
		State.Content.Sections.CouponFlow.Enabled = true;
		EnsureSectionGroupKey("coupon-flow", "storeSearch", "store-search", "couponPeriod", "coupon-period");
		MoveSectionGroupAfter("coupon-flow", "storeSearch", "store-search", "couponPeriod", "coupon-period");
		EnsureCouponFlowDefaults();
		await UpdatePreviewAsync();
	}

	private async void AddStickyTabsSection()
	{
		State.Content.Sections.StickyTabs.Enabled = true;
		EnsureSectionGroupKey("sticky-tabs", "couponNotes", "coupon-notes");
		MoveSectionGroupAfter("sticky-tabs", "couponNotes", "coupon-notes");
		EnsureStickyTabsDefaults();
		SelectedStickyTabIndex = 0;
		await UpdatePreviewAsync();
	}

	private async void AddCustomSection()
	{
		var key = GenerateCustomSectionKey();
		var model = new CustomSectionModel
		{
			Key = key,
			Title = "セクションタイトル",
			Body = string.Empty,
			ImagePath = $"images/{key}.png",
			ImageAlt = string.Empty,
			LinkUrl = string.Empty,
			Notes = string.Empty,
			BodyTextItems = new List<StyledTextItem>(),
			ImageNotesItems = new List<StyledTextItem>()
		};
		State.Content.CustomSections.Add(model);
		EnsureSectionGroupKey(key, "couponNotes", "coupon-notes");
		MoveSectionGroupAfter(key, "couponNotes", "coupon-notes");
		await UpdatePreviewAsync();
	}

	private async void AddStoreSearchSection()
	{
		State.Content.Sections.StoreSearch.Enabled = true;
		if (string.IsNullOrWhiteSpace(State.Content.Sections.StoreSearch.Title))
		{
			State.Content.Sections.StoreSearch.Title = "対象店舗検索";
		}
		if (string.IsNullOrWhiteSpace(State.Content.Sections.StoreSearch.NoticeTitle))
		{
			State.Content.Sections.StoreSearch.NoticeTitle = "⚠️ ご注意ください！";
		}
		if (State.Content.Sections.StoreSearch.NoticeItems.Count == 0)
		{
			var defaults = new[]
			{
				new TextItemModel { Text = "リストに記載があっても、店舗の休業・閉業・移転や、その他の事情により利用できない場合があります。" },
				new TextItemModel { Text = "キャンペーン対象店舗であっても、一部掲載していない店舗もございます。" },
				new TextItemModel { Text = "データ連携のタイムラグ等により、キャッシュレス決済アプリ内の情報と一部異なる場合があります。" },
				new TextItemModel { Text = "店舗は随時追加・更新いたします。" },
				new TextItemModel { Text = "一部対象外商品、サービスがあります。" }
			};
			foreach (var item in defaults)
			{
				ApplyDefaultFontSize(item);
			}
			State.Content.Sections.StoreSearch.NoticeItems.AddRange(defaults);
		}
		var key = GetStoreSearchGroupKey();
		if (State.Template is not null)
		{
			if (!State.Template.SectionGroupKeys.Any(value => string.Equals(value, key, StringComparison.OrdinalIgnoreCase)))
			{
				State.Template.SectionGroupKeys.Add(key);
			}
		}
		EnsureSectionGroupKey(key, "couponNotes", "coupon-notes", "couponPeriod", "coupon-period");
		EnableSectionGroup(key);
		MoveSectionGroupAfter(key, "couponNotes", "coupon-notes", "couponPeriod", "coupon-period");
		if (State.Template is not null)
		{
			TemplateService.EnsureSectionGroups(State.Content, State.Template.SectionGroupKeys);
			EnsureSectionGroupKey(key, "couponNotes", "coupon-notes", "couponPeriod", "coupon-period");
			EnableSectionGroup(key);
			MoveSectionGroupAfter(key, "couponNotes", "coupon-notes", "couponPeriod", "coupon-period");
		}
		if (!HasSectionGroup(key))
		{
			State.Content.SectionGroups.Add(new SectionGroupModel { Key = key, Enabled = true });
			MoveSectionGroupAfter(key, "couponNotes", "coupon-notes", "couponPeriod", "coupon-period");
		}
		await UpdatePreviewAsync();
	}

	private int SelectedStickyTabIndex { get; set; }
	private StickyBlockType NewStickyBlockType { get; set; } = StickyBlockType.RichText;
	private void TriggerStickyTabsHighlight()
	{
		TriggerSlotHighlight("tabs", "glow");
	}
	private static readonly string[] StickyTabPalette = new[]
	{
		"#E11D48",
		"#F97316",
		"#F59E0B",
		"#10B981",
		"#22C55E",
		"#0EA5E9",
		"#6366F1",
		"#8B5CF6",
		"#EC4899",
		"#111827",
		"#334155",
		"#F87171"
	};

	private void SelectStickyTab(int index)
	{
		SelectedStickyTabIndex = index;
	}

	private static bool IsStickyTabTextAuto(StickyTabModel tab)
	{
		return string.IsNullOrWhiteSpace(tab.TextColor);
	}

	private static string ToColorPickerValue(string? color)
	{
		if (string.IsNullOrWhiteSpace(color))
		{
			return "#ffffff";
		}

		var trimmed = color.Trim();
		if (trimmed.StartsWith('#') && trimmed.Length == 4)
		{
			return $"#{trimmed[1]}{trimmed[1]}{trimmed[2]}{trimmed[2]}{trimmed[3]}{trimmed[3]}";
		}
		if (trimmed.StartsWith('#') && trimmed.Length == 7)
		{
			return trimmed;
		}

		return "#ffffff";
	}

	private static string ResolveStickyTabEditorTextColor(string? backgroundColor, string? manualTextColor)
	{
		if (!string.IsNullOrWhiteSpace(manualTextColor))
		{
			return manualTextColor;
		}

		if (!TryParseHexColor(backgroundColor, out var r, out var g, out var b))
		{
			return "#111827";
		}

		var luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255d;
		return luminance > 0.6 ? "#111827" : "#ffffff";
	}

	private static bool TryParseHexColor(string? value, out int r, out int g, out int b)
	{
		r = g = b = 0;
		if (string.IsNullOrWhiteSpace(value))
		{
			return false;
		}

		var hex = value.Trim();
		if (hex.StartsWith('#'))
		{
			hex = hex[1..];
		}

		if (hex.Length == 3)
		{
			hex = string.Concat(hex[0], hex[0], hex[1], hex[1], hex[2], hex[2]);
		}

		if (hex.Length != 6)
		{
			return false;
		}

		return int.TryParse(hex.AsSpan(0, 2), System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out r)
			&& int.TryParse(hex.AsSpan(2, 2), System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out g)
			&& int.TryParse(hex.AsSpan(4, 2), System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out b);
	}

	private async void AddStickyTab()
	{
		var model = State.Content.Sections.StickyTabs;
		model.Tabs.Add(new StickyTabModel
		{
			Title = "新しいタブ",
			Color = string.Empty,
			ContentBlocks = new List<StickyBlockModel>
			{
				new StickyBlockModel { Type = StickyBlockType.RichText, RichTextHtml = "テキストを入力してください" }
			}
		});
		SelectedStickyTabIndex = model.Tabs.Count - 1;
		await UpdatePreviewAsync();
		TriggerStickyTabsHighlight();
	}

	private async void SetStickyTabColor(StickyTabModel tab, string? color)
	{
		tab.Color = color ?? string.Empty;
		await UpdatePreviewAsync();
		TriggerStickyTabsHighlight();
	}

	private async void SetStickyTabTextColorMode(StickyTabModel tab, ChangeEventArgs e)
	{
		var isAuto = e?.Value is bool b && b;
		if (isAuto)
		{
			tab.TextColor = string.Empty;
		}
		else if (string.IsNullOrWhiteSpace(tab.TextColor))
		{
			tab.TextColor = "#111827";
		}
		await UpdatePreviewAsync();
		TriggerStickyTabsHighlight();
	}

	private async void SetStickyTabTextColor(StickyTabModel tab, string? color)
	{
		tab.TextColor = color ?? string.Empty;
		await UpdatePreviewAsync();
		TriggerStickyTabsHighlight();
	}

	private async void RemoveStickyTabWithConfirm(int index)
	{
		var ok = await JS.InvokeAsync<bool>("confirm", "このタブを削除しますか？");
		if (!ok)
		{
			return;
		}
		RemoveStickyTab(index);
	}

	private async void RemoveStickyTab(int index)
	{
		var model = State.Content.Sections.StickyTabs;
		if (index < 0 || index >= model.Tabs.Count)
		{
			return;
		}
		model.Tabs.RemoveAt(index);
		SelectedStickyTabIndex = Math.Clamp(SelectedStickyTabIndex, 0, Math.Max(0, model.Tabs.Count - 1));
		await UpdatePreviewAsync();
		TriggerStickyTabsHighlight();
	}

	private async void DuplicateStickyTab(int index)
	{
		var model = State.Content.Sections.StickyTabs;
		if (index < 0 || index >= model.Tabs.Count)
		{
			return;
		}
		var source = model.Tabs[index];
		var clone = new StickyTabModel
		{
			Title = string.IsNullOrWhiteSpace(source.Title) ? "新しいタブ" : $"{source.Title}（コピー）",
			Color = source.Color,
			TextColor = source.TextColor,
			ContentBlocks = source.ContentBlocks.Select(CloneStickyBlock).ToList()
		};
		model.Tabs.Insert(index + 1, clone);
		SelectedStickyTabIndex = index + 1;
		await UpdatePreviewAsync();
		TriggerStickyTabsHighlight();
	}

	private static StickyBlockModel CloneStickyBlock(StickyBlockModel block)
	{
		return new StickyBlockModel
		{
			Type = block.Type,
			RichTextHtml = block.RichTextHtml,
			ImageSrc = block.ImageSrc,
			Caption = block.Caption
		};
	}

	private async void MoveStickyTab(int index, int delta)
	{
		var model = State.Content.Sections.StickyTabs;
		var next = index + delta;
		if (index < 0 || index >= model.Tabs.Count || next < 0 || next >= model.Tabs.Count)
		{
			return;
		}
		var item = model.Tabs[index];
		model.Tabs.RemoveAt(index);
		model.Tabs.Insert(next, item);
		SelectedStickyTabIndex = next;
		await UpdatePreviewAsync();
		TriggerStickyTabsHighlight();
	}

	private async void AddStickyBlock(StickyTabModel tab, StickyBlockType type)
	{
		tab.ContentBlocks.Add(CreateStickyBlock(type));
		await UpdatePreviewAsync();
	}

	private async void RemoveStickyBlock(StickyTabModel tab, int index)
	{
		if (index < 0 || index >= tab.ContentBlocks.Count)
		{
			return;
		}
		tab.ContentBlocks.RemoveAt(index);
		await UpdatePreviewAsync();
	}

	private async void DuplicateStickyBlock(StickyTabModel tab, int index)
	{
		if (index < 0 || index >= tab.ContentBlocks.Count)
		{
			return;
		}
		var clone = CloneStickyBlock(tab.ContentBlocks[index]);
		tab.ContentBlocks.Insert(index + 1, clone);
		await UpdatePreviewAsync();
	}

	private async void MoveStickyBlock(StickyTabModel tab, int index, int delta)
	{
		var next = index + delta;
		if (index < 0 || index >= tab.ContentBlocks.Count || next < 0 || next >= tab.ContentBlocks.Count)
		{
			return;
		}
		var item = tab.ContentBlocks[index];
		tab.ContentBlocks.RemoveAt(index);
		tab.ContentBlocks.Insert(next, item);
		await UpdatePreviewAsync();
	}

	private static StickyBlockModel CreateStickyBlock(StickyBlockType type)
	{
		return type switch
		{
			StickyBlockType.Image => new StickyBlockModel
			{
				Type = type,
				ImageSrc = "images/benefit-sample.png"
			},
			StickyBlockType.ImageWithCaption => new StickyBlockModel
			{
				Type = type,
				ImageSrc = "images/benefit-sample.png",
				Caption = "特典内容のイメージです。"
			},
			StickyBlockType.Divider => new StickyBlockModel
			{
				Type = type
			},
			_ => new StickyBlockModel
			{
				Type = StickyBlockType.RichText,
				RichTextHtml = "テキストを入力してください"
			}
		};
	}

	private static string GetStickyBlockTypeLabel(StickyBlockType type)
	{
		return type switch
		{
			StickyBlockType.Image => "画像",
			StickyBlockType.ImageWithCaption => "画像＋キャプション",
			StickyBlockType.Divider => "区切り線",
			_ => "リッチテキスト"
		};
	}

	private void EnsureStickyTabsDefaults()
	{
		var model = State.Content.Sections.StickyTabs;
		if (model.Tabs.Count > 0)
		{
			return;
		}
		model.Tabs.AddRange(new[]
		{
			new StickyTabModel
			{
				Title = "本キャンペーン注意事項",
				Color = "#d91f2a",
				ContentBlocks = new List<StickyBlockModel>
				{
					new StickyBlockModel { Type = StickyBlockType.RichText, RichTextHtml = "・抽選・当選共に1au IDあたり1回です。\n・当選者の発表はポイントの加算をもって代えさせていただきます。\n・抽選結果についてはお問い合わせいただいても回答できません。" }
				}
			},
			new StickyTabModel
			{
				Title = "特典内容",
				Color = "#f4c44e",
				ContentBlocks = new List<StickyBlockModel>
				{
					new StickyBlockModel { Type = StickyBlockType.ImageWithCaption, ImageSrc = "images/benefit-sample.png", Caption = "特典内容のイメージです。" },
					new StickyBlockModel { Type = StickyBlockType.RichText, RichTextHtml = "特典内容の詳細を記載します。" }
				}
			}
		});
	}

	private async void AddCouponFlowSlide()
	{
		State.Content.Sections.CouponFlow.Slides.Add(new CouponFlowSlideModel
		{
			Image = "images/slide-img.png",
			Alt = string.Empty
		});
		await UpdatePreviewAsync();
	}

	private async void RemoveCouponFlowSlide(CouponFlowSlideModel slide)
	{
		State.Content.Sections.CouponFlow.Slides.Remove(slide);
		await UpdatePreviewAsync();
	}

	private void EnsureCouponFlowDefaults()
	{
		var flow = State.Content.Sections.CouponFlow;
		if (string.IsNullOrWhiteSpace(flow.Title))
		{
			flow.Title = "クーポン利用の流れ";
		}
		if (string.IsNullOrWhiteSpace(flow.Lead))
		{
			flow.Lead = "＊必ずクーポンを獲得してからau PAY（コード支払い）でお支払いください。";
		}
		if (flow.Slides.Count == 0)
		{
			flow.Slides.AddRange(new[]
			{
				new CouponFlowSlideModel { Image = "images/slide-img1.png", Alt = "1. au PAY アプリのホームの下のクーポンから獲得できます。「一覧」でクーポン画面に遷移します。" },
				new CouponFlowSlideModel { Image = "images/slide-img2.png", Alt = "2. クーポン画面で、クーポンを獲得できる他、クーポンをタップするとクーポンの詳細画面を確認することができます。" },
				new CouponFlowSlideModel { Image = "images/slide-img3.png", Alt = "3. クーポンの詳細画面でも獲得できます。" },
				new CouponFlowSlideModel { Image = "images/slide-img4.png", Alt = "4. マイクーポンが自動で適応されます。" },
				new CouponFlowSlideModel { Image = "images/slide-img5.png", Alt = "5. クーポン対象のお店で決済します。" },
				new CouponFlowSlideModel { Image = "images/slide-img6.png", Alt = "6. マイクーポンが自動で適応されます。" }
			});
		}
		if (string.IsNullOrWhiteSpace(flow.Note))
		{
			flow.Note = "※画面はイメージです。";
		}
		if (string.IsNullOrWhiteSpace(flow.ButtonLabel))
		{
			flow.ButtonLabel = "クーポンを獲得する";
		}
		if (string.IsNullOrWhiteSpace(flow.ButtonUrl))
		{
			flow.ButtonUrl = "https://app.adjust.com/8me24xf_8kvfv7e?deep_link=auwallet%3A%2F%2Fhttps%3A%2F%2Faupay.auone.jp%2Fcoupon%2Findex.html&adgroup&creative";
		}
		if (flow.Items.Count == 0)
		{
			flow.Items.AddRange(new[]
			{
				new TextItemModel { Text = "※スマートフォンもしくはタブレットからご確認ください" },
				new TextItemModel { Text = "※上記「クーポンを獲得する」ボタンからアプリへ遷移できます。" },
				new TextItemModel { Text = "※クーポンは、1月1日(木・祝)から獲得できます。" }
			});
		}
	}

	private void EnsurePaymentHistoryDefaults()
	{
		var history = State.Content.Sections.PaymentHistory;
		if (string.IsNullOrWhiteSpace(history.TitleText))
		{
			history.TitleText = "決済履歴の確認方法";
		}
		if (string.IsNullOrWhiteSpace(history.TitleAlt))
		{
			history.TitleAlt = "決済履歴の確認方法";
		}
		if (history.TitleFontSize is null or <= 0)
		{
			history.TitleFontSize = 28;
		}
		if (string.IsNullOrWhiteSpace(history.TitleColor))
		{
			history.TitleColor = "#ffffff";
		}
		if (string.IsNullOrWhiteSpace(history.Text))
		{
			history.Text = "現在の決済金額については、au PAY アプリ内の「取引履歴」をご確認ください。<br class=\"_view-md-high\">取引履歴の確認方法については<a href=\"#contact\">こちら</a>までお問い合わせください。";
		}
		if (history.TextFontSize is null or <= 0)
		{
			history.TextFontSize = 22;
		}
		if (string.IsNullOrWhiteSpace(history.ImportantText))
		{
			history.ImportantText = "なお、店頭や問い合わせ窓口での現在の順位や金額、<br class=\"_view-md-high\">当選結果についてのご質問にはお答えできません。";
		}
		if (history.ImportantFontSize is null or <= 0)
		{
			history.ImportantFontSize = 22;
		}
		if (string.IsNullOrWhiteSpace(history.ImportantColor))
		{
			history.ImportantColor = "#BF1D20";
		}
		if (string.IsNullOrWhiteSpace(history.Image))
		{
			history.Image = "images/img-02.png";
		}
		if (string.IsNullOrWhiteSpace(history.ImageAlt))
		{
			history.ImageAlt = "スマートフォン画像";
		}
	}

	private async Task OnStoreExcelSelected(InputFileChangeEventArgs e)
	{
		State.Error.Clear();
		try
		{
			var file = e.File;
			if (file is null)
			{
				return;
			}

			using var ms = new MemoryStream();
			await file.OpenReadStream(long.MaxValue).CopyToAsync(ms);
			ms.Position = 0;

			using var workbook = new XLWorkbook(ms);
			var sheet = workbook.Worksheets.FirstOrDefault();
			if (sheet is null)
			{
				return;
			}

			var headerRow = sheet.FirstRowUsed();
			if (headerRow is null)
			{
				return;
			}

			var headerMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
			foreach (var cell in headerRow.CellsUsed())
			{
				var key = cell.GetString().Trim();
				if (!string.IsNullOrWhiteSpace(key))
				{
					headerMap[key] = cell.Address.ColumnNumber;
				}
			}

			int Col(string name) => headerMap.TryGetValue(name, out var index) ? index : -1;

			var idCol = Col("店舗ID");
			var nameCol = Col("店舗名");
			var zipCol = Col("郵便番号");
			var addressCol = Col("住所");
			var couponCol = Col("クーポン対象");
			var raffleCol = Col("抽選対象");
			var campaignCol = Col("キャンペーン対象");
			var latCol = Col("緯度");
			var lngCol = Col("経度");

			var fixedColumns = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
			{
				"店舗ID",
				"店舗名",
				"郵便番号",
				"住所",
				"緯度",
				"経度"
			};
			var labelColumns = headerMap
				.Where(pair => !fixedColumns.Contains(pair.Key))
				.Select(pair => new StoreTargetLabelModel
				{
					Key = NormalizeLabelKey(pair.Key),
					Name = pair.Key,
					IsEnabled = true,
					UpdatedAt = DateTime.UtcNow
				})
				.Where(label => !string.IsNullOrWhiteSpace(label.Key))
				.ToList();

			var stores = new List<StoreItemModel>();
			foreach (var row in sheet.RowsUsed().Skip(1))
			{
				var name = GetCellString(row, nameCol);
				var address = GetCellString(row, addressCol);
				if (string.IsNullOrWhiteSpace(name) && string.IsNullOrWhiteSpace(address))
				{
					continue;
				}

				var targets = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
				foreach (var label in labelColumns)
				{
					if (!headerMap.TryGetValue(label.Name, out var colIndex))
					{
						continue;
					}

					var cellValue = GetCellString(row, colIndex);
					targets[label.Key] = IsTargetValue(cellValue);
				}

				stores.Add(new StoreItemModel
				{
					Id = GetCellString(row, idCol),
					Name = name,
					Zip = GetCellString(row, zipCol),
					Address = address,
					Latitude = GetCellDouble(row, latCol),
					Longitude = GetCellDouble(row, lngCol),
					CouponTarget = GetCellBool(row, couponCol),
					RaffleTarget = GetCellBool(row, raffleCol),
					CampaignTarget = GetCellBool(row, campaignCol),
					Targets = targets
				});
			}

			State.Content.Sections.StoreSearch.Stores = stores;
			State.Content.Sections.StoreSearch.TargetLabels = labelColumns;
			await UpdatePreviewAsync();
		}
		catch (Exception ex)
		{
			State.Error.SetError("Excel読み込みに失敗", ex.Message);
		}
	}

	private static string GetCellString(IXLRow row, int col)
	{
		if (col <= 0)
		{
			return string.Empty;
		}

		return row.Cell(col).GetValue<string>()?.Trim() ?? string.Empty;
	}

	private static bool GetCellBool(IXLRow row, int col)
	{
		if (col <= 0)
		{
			return false;
		}

		var value = row.Cell(col).GetValue<string>()?.Trim();
		return string.Equals(value, "TRUE", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(value, "1", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(value, "はい", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(value, "○", StringComparison.OrdinalIgnoreCase);
	}

	private static bool IsTargetValue(string? value)
	{
		if (string.IsNullOrWhiteSpace(value))
		{
			return false;
		}

		return string.Equals(value, "対象", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(value, "TRUE", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(value, "1", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(value, "はい", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(value, "○", StringComparison.OrdinalIgnoreCase);
	}

	private static string NormalizeLabelKey(string label)
	{
		if (string.IsNullOrWhiteSpace(label))
		{
			return string.Empty;
		}

		var chars = label.Trim().ToLowerInvariant()
			.Where(c => char.IsLetterOrDigit(c) || c == '-' || c == '_')
			.ToArray();
		return new string(chars);
	}

	private static double? GetCellDouble(IXLRow row, int col)
	{
		if (col <= 0)
		{
			return null;
		}

		var value = row.Cell(col).GetValue<string>()?.Trim();
		if (double.TryParse(value, System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out var result))
		{
			return result;
		}

		if (double.TryParse(value, out result))
		{
			return result;
		}

		return null;
	}

	private async void AddRankingRow()
	{
		State.Content.Sections.Ranking.Rows.Add(new RankingRowModel());
		await UpdatePreviewAsync();
	}

	private void EnsureRankingHeaderLabels()
	{
		var headers = State.Content.Sections.Ranking.HeaderLabels;
		if (headers is null || headers.Count == 0)
		{
			State.Content.Sections.Ranking.HeaderLabels = new List<string> { "順位", "決済金額", "品数" };
		}
	}

	private void EnsureRankingRefDefaults()
	{
		var ranking = State.Content.Sections.Ranking;
		if (string.IsNullOrWhiteSpace(ranking.Title))
		{
			ranking.Title = "最新順位はこちら";
		}
		if (string.IsNullOrWhiteSpace(ranking.CampaignName))
		{
			ranking.CampaignName = "キャンペーン名";
		}
		if (string.IsNullOrWhiteSpace(ranking.PeriodText))
		{
			ranking.PeriodText = "YYYY/MM/DD〜YYYY/MM/DD";
		}
		if (string.IsNullOrWhiteSpace(ranking.AsOfText))
		{
			ranking.AsOfText = "YYYY/MM/DD時点";
		}
		EnsureRankingHeaderLabels();
		if (ranking.Rows.Count == 0)
		{
			ranking.Rows.AddRange(new[]
			{
				new RankingRowModel { Rank = "1", Amount = "000,000円", Items = "000品以上" },
				new RankingRowModel { Rank = "2", Amount = "000,000円", Items = "000品以上" },
				new RankingRowModel { Rank = "3", Amount = "000,000円", Items = "000品以上" },
				new RankingRowModel { Rank = "4", Amount = "000,000円", Items = "000品以上" },
				new RankingRowModel { Rank = "10", Amount = "000,000円", Items = "000品以上" },
				new RankingRowModel { Rank = "100", Amount = "000,000円", Items = "000品以上" },
				new RankingRowModel { Rank = "300", Amount = "000,000円", Items = "000品以上" },
				new RankingRowModel { Rank = "1,000", Amount = "000,000円", Items = "000品以上" }
			});
		}
		if (ranking.NotesItems.Count == 0)
		{
			ranking.NotesItems.Add(new StyledTextItem { Text = "※注意書きを入力してください", Align = "left", Visible = true, Id = Guid.NewGuid() });
		}
		ranking.LeftTopImage ??= new RankingDecorImageModel();
		ranking.RightTopImage ??= new RankingDecorImageModel();
	}

	private int GetRankingHeaderCount()
	{
		EnsureRankingHeaderLabels();
		return State.Content.Sections.Ranking.HeaderLabels.Count;
	}

	private void AddRankingHeader()
	{
		EnsureRankingHeaderLabels();
		var headers = State.Content.Sections.Ranking.HeaderLabels;
		if (headers.Count >= 3)
		{
			return;
		}

		headers.Add("品数");
		_ = UpdatePreviewAsync();
	}

	private async void RemoveRankingRow(RankingRowModel row)
	{
		State.Content.Sections.Ranking.Rows.Remove(row);
		await UpdatePreviewAsync();
	}

	private async void AddRankingText()
	{
		var item = new RankingTextItemModel();
		ApplyDefaultFontSize(item);
		State.Content.Sections.Ranking.Texts.Add(item);
		await UpdatePreviewAsync();
	}

	private async void RemoveRankingText(RankingTextItemModel item)
	{
		State.Content.Sections.Ranking.Texts.Remove(item);
		await UpdatePreviewAsync();
	}

	private async void RemoveCustomSection(CustomSectionModel section)
	{
		State.Content.CustomSections.Remove(section);
		State.Content.SectionGroups = State.Content.SectionGroups
			.Where(group => !string.Equals(group.Key, section.Key, StringComparison.OrdinalIgnoreCase))
			.ToList();
		await UpdatePreviewAsync();
	}

	private void EnsureSectionGroupKey(string key, params string[] insertAfterKeys)
	{
		if (string.IsNullOrWhiteSpace(key))
		{
			return;
		}

		if (State.Content.SectionGroups.Any(group => string.Equals(group.Key, key, StringComparison.OrdinalIgnoreCase)))
		{
			return;
		}

		if (insertAfterKeys is not null && insertAfterKeys.Length > 0)
		{
			foreach (var insertAfterKey in insertAfterKeys)
			{
				if (string.IsNullOrWhiteSpace(insertAfterKey))
				{
					continue;
				}

				var index = State.Content.SectionGroups.FindIndex(group => string.Equals(group.Key, insertAfterKey, StringComparison.OrdinalIgnoreCase));
				if (index >= 0)
				{
					State.Content.SectionGroups.Insert(index + 1, new SectionGroupModel { Key = key, Enabled = true });
					return;
				}
			}
		}

		State.Content.SectionGroups.Add(new SectionGroupModel { Key = key, Enabled = true });
	}

	private void EnableSectionGroup(string key)
	{
		var target = State.Content.SectionGroups
			.FirstOrDefault(group => string.Equals(group.Key, key, StringComparison.OrdinalIgnoreCase));
		if (target is not null)
		{
			target.Enabled = true;
		}
	}

	private string GetStoreSearchGroupKey()
	{
		if (HasSectionGroup("store-search"))
		{
			return "store-search";
		}

		if (HasSectionGroup("storeSearch"))
		{
			return "storeSearch";
		}

		if (State.Template is not null)
		{
			if (State.Template.SectionGroupKeys.Any(value => string.Equals(value, "store-search", StringComparison.OrdinalIgnoreCase)))
			{
				return "store-search";
			}

			if (State.Template.SectionGroupKeys.Any(value => string.Equals(value, "storeSearch", StringComparison.OrdinalIgnoreCase)))
			{
				return "storeSearch";
			}
		}

		return "store-search";
	}

	private void MoveSectionGroupAfter(string key, params string[] afterKeys)
	{
		if (string.IsNullOrWhiteSpace(key))
		{
			return;
		}

		var list = State.Content.SectionGroups;
		var currentIndex = list.FindIndex(group => string.Equals(group.Key, key, StringComparison.OrdinalIgnoreCase));
		if (currentIndex < 0)
		{
			return;
		}

		var afterIndex = -1;
		foreach (var afterKey in afterKeys)
		{
			if (string.IsNullOrWhiteSpace(afterKey))
			{
				continue;
			}

			afterIndex = list.FindIndex(group => string.Equals(group.Key, afterKey, StringComparison.OrdinalIgnoreCase));
			if (afterIndex >= 0)
			{
				break;
			}
		}

		if (afterIndex < 0 || afterIndex == currentIndex || afterIndex + 1 == currentIndex)
		{
			return;
		}

		var item = list[currentIndex];
		list.RemoveAt(currentIndex);
		if (afterIndex > currentIndex)
		{
			afterIndex--;
		}
		list.Insert(afterIndex + 1, item);
		State.Content.SectionGroups = list.ToList();
	}

	private bool HasSectionGroup(string key)
	{
		return State.Content.SectionGroups.Any(group => string.Equals(group.Key, key, StringComparison.OrdinalIgnoreCase));
	}

	private readonly HashSet<string> ExpandedSections = new(StringComparer.OrdinalIgnoreCase);

	private void InitializeAccordionDefaults()
	{
		ExpandedSections.Clear();
	}

	private bool IsSectionOpen(string key)
	{
		if (ExpandedSections.Contains(key))
		{
			return true;
		}

		return false;
	}

	private void ToggleSection(string key)
	{
		if (!ExpandedSections.Add(key))
		{
			ExpandedSections.Remove(key);
		}
	}

	private void OpenSection(string key)
	{
		ExpandedSections.Add(key);
	}

	private bool HasSectionGroupPrefix(string prefix)
	{
		if (string.IsNullOrWhiteSpace(prefix))
		{
			return false;
		}

		return State.Content.SectionGroups.Any(group =>
			!string.IsNullOrWhiteSpace(group.Key)
			&& group.Key.StartsWith(prefix, StringComparison.OrdinalIgnoreCase));
	}

	private string GenerateCustomSectionKey()
	{
		var baseKey = "custom-section";
		var index = 1;
		var existing = new HashSet<string>(State.Content.SectionGroups.Select(group => group.Key), StringComparer.OrdinalIgnoreCase);
		while (existing.Contains($"{baseKey}-{index}"))
		{
			index++;
		}

		return $"{baseKey}-{index}";
	}

	private async Task OnSectionGroupChanged()
	{
		await UpdatePreviewAsync();
	}

	private async Task RemoveSectionGroupAsync(string key)
	{
		if (string.IsNullOrWhiteSpace(key))
		{
			return;
		}

		var ok = await JS.InvokeAsync<bool>("confirm", $"{key} を削除しますか？");
		if (!ok)
		{
			return;
		}

		State.Content.SectionGroups = State.Content.SectionGroups
			.Where(group => !string.Equals(group.Key, key, StringComparison.OrdinalIgnoreCase))
			.ToList();

		if (State.Template is not null)
		{
			State.Template.SectionGroupKeys = State.Template.SectionGroupKeys
				.Where(value => !string.Equals(value, key, StringComparison.OrdinalIgnoreCase))
				.ToList();
		}

		if (string.Equals(key, "ranking", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.Ranking.Enabled = false;
		}
		if (string.Equals(key, "payment-history", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "paymentHistory", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.PaymentHistory.Enabled = false;
		}
		if (key.StartsWith("store-search", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.StoreSearch.Enabled = false;
		}
		if (string.Equals(key, "campaign-content", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "campaignContent", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.CampaignContent.Enabled = false;
		}
		if (string.Equals(key, "coupon-period", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "couponPeriod", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.CouponPeriod.Enabled = false;
		}
		if (string.Equals(key, "coupon-notes", StringComparison.OrdinalIgnoreCase)
			|| string.Equals(key, "couponNotes", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.CouponNotes.Enabled = false;
		}
		if (string.Equals(key, "conditions", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.Conditions.Enabled = false;
		}
		if (string.Equals(key, "contact", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.Contact.Enabled = false;
		}
		if (key.Contains("banner", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.Banners.Enabled = false;
		}
		if (key.Contains("conditions-contact-banners", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Sections.Conditions.Enabled = false;
			State.Content.Sections.Contact.Enabled = false;
			State.Content.Sections.Banners.Enabled = false;
		}
		if (string.Equals(key, "countdown", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.Campaign.ShowCountdown = false;
		}
		if (key.StartsWith("custom-section", StringComparison.OrdinalIgnoreCase))
		{
			State.Content.CustomSections = State.Content.CustomSections
				.Where(section => !string.Equals(section.Key, key, StringComparison.OrdinalIgnoreCase))
				.ToList();
		}

		await UpdatePreviewAsync();
	}


	private async void MoveSectionGroup(int index, int direction)
	{
		var list = State.Content.SectionGroups;
		if (list is null || list.Count == 0)
		{
			return;
		}

		if (index < 0 || index >= list.Count)
		{
			return;
		}

		var targetIndex = index + direction;
		if (targetIndex < 0 || targetIndex >= list.Count)
		{
			return;
		}

		var item = list[index];
		list.RemoveAt(index);
		list.Insert(targetIndex, item);
		State.Content.SectionGroups = list.ToList();
		await UpdatePreviewAsync();
	}

	private DotNetObjectReference<Home>? SectionSortRef;
	private DotNetObjectReference<Home>? SectionNavRef;
	private DotNetObjectReference<Home>? PreviewResizeRef;

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		await SetupSortableAsync();
		await SetupSectionObserverAsync();
		if (firstRender)
		{
			await SetupPreviewDebugListenerAsync();
			await SetupPreviewResizeAsync();
			await EnsureDefaultPreviewWidthAsync();
			await LoadRecentCardColorsAsync();
		}
	}

	private async Task SetupPreviewDebugListenerAsync()
	{
		await JS.InvokeVoidAsync("lpPreview.registerDebugListener");
	}

	private async Task SetupPreviewResizeAsync()
	{
		PreviewResizeRef ??= DotNetObjectReference.Create(this);
		await JS.InvokeVoidAsync("lpSplit.init", "lpEditorRoot", "previewPane", "previewSplitter", PreviewResizeRef);
	}

	private async Task EnsureDefaultPreviewWidthAsync()
	{
		State.PreviewIsMobile = false;
		IsResponsivePreview = false;
		UseViewportSizing = false;
		await JS.InvokeVoidAsync("lpSplit.setPreviewWidth", "lpEditorRoot", "previewPane", PcPreviewWidth);
		await InvokeAsync(StateHasChanged);
	}


	private async Task SetupSortableAsync()
	{
		SectionSortRef ??= DotNetObjectReference.Create(this);
		for (var attempt = 0; attempt < 10; attempt++)
		{
			var ok = await JS.InvokeAsync<bool>("sectionSortBridge.trySetup", "sectionList", SectionSortRef);
			if (ok)
			{
				return;
			}

			await Task.Delay(100);
		}
	}

	private async Task SetupSectionObserverAsync()
	{
		try
		{
			SectionNavRef ??= DotNetObjectReference.Create(this);
			await JS.InvokeVoidAsync("sectionNav.setup", "previewFrame", SectionNavRef);
		}
		catch
		{
			// no-op
		}
	}

	[JSInvokable]
	public async Task OnSectionOrderChanged(string[] order)
	{
		if (order is null || order.Length == 0)
		{
			return;
		}

		var map = State.Content.SectionGroups
			.Where(group => !string.IsNullOrWhiteSpace(group.Key))
			.ToDictionary(group => group.Key, group => group, StringComparer.OrdinalIgnoreCase);
		var next = new List<SectionGroupModel>();
		foreach (var key in order)
		{
			if (string.IsNullOrWhiteSpace(key))
			{
				continue;
			}

			if (map.TryGetValue(key, out var group))
			{
				next.Add(group);
				map.Remove(key);
			}
		}

		foreach (var group in map.Values)
		{
			next.Add(group);
		}

		State.Content.SectionGroups = next;
		var keysLog = string.Join(", ", State.Content.SectionGroups.Select(group => group.Key));
		System.Diagnostics.Debug.WriteLine($"[SectionOrder] after reorder: {keysLog}");
		Console.WriteLine($"[SectionOrder] after reorder: {keysLog}");
		await UpdatePreviewAsync();
		await SetupSortableAsync();
	}

	[JSInvokable]
	public Task OnPreviewSectionChanged(string sectionId)
	{
		var normalized = NormalizeSectionKey(sectionId);
		if (string.Equals(CurrentPreviewSectionId, normalized, StringComparison.OrdinalIgnoreCase))
		{
			return Task.CompletedTask;
		}
		CurrentPreviewSectionId = normalized;
		if (FollowActiveSection)
		{
			_ = JS.InvokeVoidAsync("sectionNav.scrollRow", "sectionList", GetSectionRowId(normalized));
		}
		return InvokeAsync(StateHasChanged);
	}

	[JSInvokable]
	public Task OnPreviewWidthChanged(int width)
	{
		if (UseViewportSizing)
		{
			return Task.CompletedTask;
		}

		if (!HasPreviewModeSelection)
		{
			return Task.CompletedTask;
		}

		var isMobile = width < 600;
		if (State.PreviewIsMobile == isMobile)
		{
			return Task.CompletedTask;
		}

		State.PreviewIsMobile = isMobile;
		return InvokeAsync(StateHasChanged);
	}

	public async ValueTask DisposeAsync()
	{
		if (_highlightHandler is not null)
		{
			HighlightService.OnRequested -= _highlightHandler;
			_highlightHandler = null;
		}
		SectionSortRef?.Dispose();
		SectionNavRef?.Dispose();
		PreviewResizeRef?.Dispose();
		await Task.CompletedTask;
	}

	private async Task UpdatePreviewAsync()
	{
		State.Error.Clear();
		var startedAt = DateTime.UtcNow;
		IsPreviewLoading = true;
		await InvokeAsync(StateHasChanged);
		var scrollTop = 0;
		try
		{
			scrollTop = await JS.InvokeAsync<int>("lpPreview.getScrollTop", "previewFrame");
		}
		catch
		{
			scrollTop = 0;
		}
		try
		{
			if (IsImportMode && ImportProject is not null)
			{
				State.PreviewHtml = await LpImportService.BuildPreviewHtmlAsync(ImportProject);
				State.PreviewHtml = $"<!-- {DateTime.Now:HH:mm:ss.fff} -->" + State.PreviewHtml;
			}
			else if (State.Template is null)
			{
				State.PreviewHtml = "<html><body><div style='padding:20px;font-family:sans-serif;'>テンプレートZIPを読み込んでください。</div></body></html>";
			}
			else
			{
				var spViewportWidth = (State.PreviewIsMobile || IsResponsivePreview)
					? EffectiveResponsiveWidth
					: (int?)null;
				var applySpResetCss = State.PreviewIsMobile || IsResponsivePreview;
				State.PreviewHtml = await PreviewService.GenerateHtmlAsync(
					State.Template,
					State.Content,
					State.ImageOverrides,
					embedImages: true,
					includeDebugStamp: true,
					editingSectionKey: SelectedSectionId,
					fixedViewportWidth: spViewportWidth,
					applySpResetCss: applySpResetCss);
			}

			PreviewVersion++;

			await JS.InvokeVoidAsync("lpPreview.setHtmlWithScroll", "previewFrame", State.PreviewHtml, scrollTop);
			await SetupSectionObserverAsync();
			if (UseViewportSizing)
			{
				await ApplyResponsiveViewportAsync();
			}
			await TrySetTemplateFontSizeAsync();
		}
		catch (Exception ex)
		{
			State.Error.SetError("プレビュー生成に失敗", ex.Message);
			State.PreviewHtml = "<html><body><div style='padding:20px;font-family:sans-serif;'>プレビュー生成に失敗しました。</div></body></html>";
			PreviewVersion++;
			await JS.InvokeVoidAsync("lpPreview.setHtmlWithScroll", "previewFrame", State.PreviewHtml, scrollTop);
			await SetupSectionObserverAsync();
		}
		var elapsed = DateTime.UtcNow - startedAt;
		if (elapsed < TimeSpan.FromMilliseconds(250))
		{
			await Task.Delay(TimeSpan.FromMilliseconds(250) - elapsed);
		}
		IsPreviewLoading = false;
		await InvokeAsync(StateHasChanged);
	}

	private async Task TrySetTemplateFontSizeAsync()
	{
		if (TemplateTextFontSize.HasValue || State.Template is null)
		{
			return;
		}

		try
		{
			var size = await JS.InvokeAsync<int>("lpPreview.getFontSize", "previewFrame", ".campaign__text, .campaign__subBox li, .c-list li");
			if (size <= 0)
			{
				return;
			}

			TemplateTextFontSize = size;
			ApplyDefaultFontSizeToAllItems();
			await InvokeAsync(StateHasChanged);
		}
		catch
		{
			return;
		}
	}

	private List<string> GetValidationIssues()
	{
		var issues = new List<string>();
		if (string.IsNullOrWhiteSpace(State.Content.Meta.PageTitle))
		{
			issues.Add("ページタイトルが未入力");
		}
		if (string.IsNullOrWhiteSpace(State.Content.Meta.Description))
		{
			issues.Add("キャンペーン内容が未入力");
		}
		if (string.IsNullOrWhiteSpace(State.Content.Campaign.StartDate))
		{
			issues.Add("開始日が未入力");
		}
		if (string.IsNullOrWhiteSpace(State.Content.Campaign.EndDate))
		{
			issues.Add("終了日が未入力");
		}
		if (string.IsNullOrWhiteSpace(State.Content.Sections.CampaignContent.Title))
		{
			issues.Add("コンテンツのセクションタイトルが未入力");
		}
		return issues;
	}

	private string GetImagePreviewSrc(string path)
	{
		if (State.ImageOverrides.TryGetValue(path, out var overrideBytes))
		{
			return ToDataUrl(overrideBytes, path);
		}

		if (State.Template is not null && State.Template.Files.TryGetValue(path, out var file) && file.IsImage)
		{
			return ToDataUrl(file.Data, path);
		}

		return string.Empty;
	}

	private void BuildImageMeta(TemplateProject template)
	{
		State.ImageMeta.Clear();
		foreach (var path in GetImagePaths(template))
		{
			if (template.Files.TryGetValue(path, out var file) && file.IsImage)
			{
				State.ImageMeta[path] = ImageService.GetImageInfo(file.Data, path);
			}
		}
	}

	private void UpdateImageMeta(string path, byte[] bytes)
	{
		State.ImageMeta[path] = ImageService.GetImageInfo(bytes, path);
	}

	private string GetImageMetaText(string path)
	{
		if (!State.ImageMeta.TryGetValue(path, out var meta) || meta.Width <= 0 || meta.Height <= 0)
		{
			return "サイズ不明";
		}

		var sizeKb = Math.Max(1, (int)Math.Ceiling(meta.Bytes / 1024d));
		return $"{meta.Width}×{meta.Height}px / {sizeKb}KB / {meta.Format}";
	}

	private bool IsImageDeleted(string path)
	{
		return State.Content.DeletedImages.Any(item => string.Equals(item, path, StringComparison.OrdinalIgnoreCase));
	}

	private async void DeleteImage(string path)
	{
		if (IsImageDeleted(path))
		{
			return;
		}

		State.Content.DeletedImages.Add(path);
		State.ImageOverrides.Remove(path);
		await UpdatePreviewAsync();
	}

	private async void RestoreImage(string path)
	{
		RemoveDeletedImage(path);
		await UpdatePreviewAsync();
	}

	private void RemoveDeletedImage(string path)
	{
		State.Content.DeletedImages = State.Content.DeletedImages
			.Where(item => !string.Equals(item, path, StringComparison.OrdinalIgnoreCase))
			.ToList();
	}

	private static string ToDataUrl(byte[] bytes, string path)
	{
		var ext = Path.GetExtension(path).ToLowerInvariant();
		var mime = ext switch
		{
			".png" => "image/png",
			".jpg" => "image/jpeg",
			".jpeg" => "image/jpeg",
			".gif" => "image/gif",
			".svg" => "image/svg+xml",
			".webp" => "image/webp",
			_ => "application/octet-stream"
		};
		var base64 = Convert.ToBase64String(bytes);
		return $"data:{mime};base64,{base64}";
	}

	private async Task OnAnyInput(ChangeEventArgs _)
	{
		await UpdatePreviewAsync();
	}

	private void OnAnyInputAfter()
	{
		_ = UpdatePreviewAsync();
	}

	private async Task NotifyChanged()
	{
		await UpdatePreviewAsync();
		await InvokeAsync(StateHasChanged);
	}

	private SectionStyleModel GetSectionStyleSettings(string key)
	{
		State.Content.SectionStyles ??= new Dictionary<string, SectionStyleModel>(StringComparer.OrdinalIgnoreCase);
		if (!State.Content.SectionStyles.TryGetValue(key, out var settings) || settings is null)
		{
			settings = new SectionStyleModel();
			State.Content.SectionStyles[key] = settings;
		}

		EnsureSectionStyleDefaults(settings, key);
		return settings;
	}

	private SectionAnimationModel GetSectionAnimationSettings(string key)
	{
		State.Content.SectionAnimations ??= new Dictionary<string, SectionAnimationModel>(StringComparer.OrdinalIgnoreCase);
		if (!State.Content.SectionAnimations.TryGetValue(key, out var settings) || settings is null)
		{
			settings = new SectionAnimationModel();
			State.Content.SectionAnimations[key] = settings;
		}

		EnsureSectionAnimationDefaults(settings);
		return settings;
	}

	private void EnsureSectionStyleDefaults(SectionStyleModel style, string key)
	{
		style.Design ??= new SectionDesignModel();
		EnsureSectionDesignDefaults(style.Design);
		style.BorderColor ??= string.Empty;
		style.BorderStyle = string.IsNullOrWhiteSpace(style.BorderStyle) ? "solid" : style.BorderStyle;
		style.Shadow ??= string.Empty;
		style.Background ??= new SectionBackgroundSettings();
		style.Divider ??= new SectionDividerModel();
		style.Divider.Style = string.IsNullOrWhiteSpace(style.Divider.Style) ? "solid" : style.Divider.Style;

		if (State.Content.SectionBackgrounds.TryGetValue(key, out var legacyBackground) && legacyBackground is not null)
		{
			style.Background.Mode = string.IsNullOrWhiteSpace(style.Background.Mode) ? legacyBackground.Mode : style.Background.Mode;
			style.Background.Color ??= legacyBackground.Color;
			style.Background.GradientColorA ??= legacyBackground.GradientColorA;
			style.Background.GradientColorB ??= legacyBackground.GradientColorB;
			style.Background.ImageUrl ??= legacyBackground.ImageUrl;
			style.Background.Repeat = string.IsNullOrWhiteSpace(style.Background.Repeat) ? legacyBackground.Repeat : style.Background.Repeat;
			style.Background.Position = string.IsNullOrWhiteSpace(style.Background.Position) ? legacyBackground.Position : style.Background.Position;
			style.Background.PositionCustom ??= legacyBackground.PositionCustom;
			style.Background.Size = string.IsNullOrWhiteSpace(style.Background.Size) ? legacyBackground.Size : style.Background.Size;
			style.Background.SizeCustom ??= legacyBackground.SizeCustom;
			style.Background.Attachment = string.IsNullOrWhiteSpace(style.Background.Attachment) ? legacyBackground.Attachment : style.Background.Attachment;
		}
	}

	private static void EnsureSectionAnimationDefaults(SectionAnimationModel animation)
	{
		animation.Type = string.IsNullOrWhiteSpace(animation.Type) ? "none" : animation.Type;
		animation.Easing = string.IsNullOrWhiteSpace(animation.Easing) ? "ease" : animation.Easing;
	}

	private static void EnsureSectionDesignDefaults(SectionDesignModel design)
	{
		design.Type = string.IsNullOrWhiteSpace(design.Type) ? "simple" : design.Type;
		design.BackgroundColor ??= "#ffffff";
		design.BackgroundOpacity ??= 1;
		design.GradientDirection ??= 135;
		design.OverlayColor ??= "#111827";
		design.OverlayOpacity ??= 0.35;
		design.BorderRadius ??= 16;
		design.PaddingPreset = string.IsNullOrWhiteSpace(design.PaddingPreset) ? "md" : design.PaddingPreset;
		design.PaddingX ??= 24;
		design.PaddingY ??= 24;
		design.MarginBottom ??= 16;
		design.BorderColor ??= "#e5e7eb";
		design.BorderWidth ??= 1;
		design.ShadowLevel = string.IsNullOrWhiteSpace(design.ShadowLevel) ? "md" : design.ShadowLevel;
		design.AccentColor ??= "#4f46e5";
		design.AccentHeight ??= 4;
		design.PatternType = string.IsNullOrWhiteSpace(design.PatternType) ? "off" : design.PatternType;
		design.Animation = string.IsNullOrWhiteSpace(design.Animation) ? "off" : design.Animation;

		if (design.BackgroundOpacity is < 0 or > 1)
		{
			design.BackgroundOpacity = 1;
		}
		if (design.OverlayOpacity is < 0 or > 1)
		{
			design.OverlayOpacity = 0.35;
		}
	}


	private IReadOnlyList<KeyValuePair<string, string>> GetDesignSectionOptions()
	{
		var options = new List<KeyValuePair<string, string>>();
		foreach (var group in State.Content.SectionGroups)
		{
			if (string.IsNullOrWhiteSpace(group.Key))
			{
				continue;
			}
			if (!IsEditorManagedSectionKey(group.Key))
			{
				continue;
			}
			if (options.Any(option => string.Equals(option.Key, group.Key, StringComparison.OrdinalIgnoreCase)))
			{
				continue;
			}
			options.Add(new KeyValuePair<string, string>(group.Key, GetSectionDisplayName(group.Key, group.DisplayName)));
		}
		foreach (var custom in State.Content.CustomSections)
		{
			if (string.IsNullOrWhiteSpace(custom.Key))
			{
				continue;
			}
			if (options.Any(option => string.Equals(option.Key, custom.Key, StringComparison.OrdinalIgnoreCase)))
			{
				continue;
			}
			options.Add(new KeyValuePair<string, string>(custom.Key, GetSectionDisplayName(custom.Key)));
		}
		return options;
	}

	private void ScheduleDesignPreview(HighlightRequest? highlightRequest = null)
	{
		_designPreviewCts?.Cancel();
		_designPreviewCts = new CancellationTokenSource();
		var token = _designPreviewCts.Token;
		_ = Task.Run(async () =>
		{
			try
			{
				await Task.Delay(150, token);
				if (token.IsCancellationRequested)
				{
					return;
				}
				await InvokeAsync(UpdatePreviewAsync);
				if (token.IsCancellationRequested)
				{
					return;
				}
				if (highlightRequest is not null)
				{
					HighlightService.Trigger(highlightRequest);
				}
			}
			catch (TaskCanceledException)
			{
			}
		});
	}

	private FrameStyle GetCardThemeStyle()
	{
		EnsureFrameDefaultStyle();
		var style = State.Content.FrameDefaultStyle ?? new FrameStyle();
		EnsureCardThemeDefaults(style);
		State.Content.FrameDefaultStyle = style;
		State.Content.CardThemeStyle = style;
		return style;
	}

	private FrameStyle GetFrameThemeEditorStyle()
	{
		if (FrameThemeTab == "per")
		{
			return GetFrameThemeOverrideStyle();
		}

		return GetCardThemeStyle();
	}

	private FrameStyle GetFrameThemeOverrideStyle()
	{
		var key = EnsureFrameThemeSectionKey();
		if (string.IsNullOrWhiteSpace(key))
		{
			return GetCardThemeStyle();
		}

		var settings = GetSectionStyleSettings(key);
		if (settings.FrameStyleOverride is null)
		{
			settings.FrameStyleOverride = new FrameStyle();
		}

		EnsureCardThemeDefaults(settings.FrameStyleOverride);
		return settings.FrameStyleOverride;
	}

	private FrameStyle GetFrameAnimationStyle()
	{
		if (FrameThemeTab != "per")
		{
			return GetCardThemeStyle();
		}

		return FrameAnimationScope == "all" ? GetCardThemeStyle() : GetFrameThemeOverrideStyle();
	}

	private void OnAnimationScopeChanged(string scope)
	{
		FrameAnimationScope = scope;
		if (FrameAnimationScope == "per")
		{
			var style = GetCardThemeStyle();
			if (style.AnimationTargets.Count > 0)
			{
				style.AnimationTargets.Clear();
			}
		}

		ScheduleDesignPreview();
	}

	private void OnAnimationPreviewToggled(bool enabled)
	{
		State.Content.AnimationPreviewEnabled = enabled;
		ScheduleDesignPreview();
	}

	private void SetFrameThemeTab(string tab)
	{
		FrameThemeTab = tab;
		if (FrameThemeTab == "per")
		{
			EnsureFrameThemeSectionKey();
		}
	}

	private void OnFrameThemeSectionChanged()
	{
		if (FrameThemeTab == "per")
		{
			EnsureFrameThemeSectionKey();
			TriggerSectionHighlight(FrameThemeSectionKey, "glow");
		}
	}

	private void ResetFrameThemeEditor()
	{
		if (FrameThemeTab == "per")
		{
			ResetFrameThemeOverride();
			return;
		}

		ResetCardTheme();
	}

	private void ResetFrameThemeOverride()
	{
		var key = EnsureFrameThemeSectionKey();
		if (string.IsNullOrWhiteSpace(key))
		{
			return;
		}

		var settings = GetSectionStyleSettings(key);
		settings.FrameStyleOverride = null;
		ScheduleDesignPreview();
	}

	private void RefreshDesignSectionOptions()
	{
		DesignSectionOptions = GetDesignSectionOptions();
	}

	private string EnsureFrameThemeSectionKey()
	{
		if (!string.IsNullOrWhiteSpace(FrameThemeSectionKey))
		{
			return FrameThemeSectionKey;
		}

		if (DesignSectionOptions.Count == 0)
		{
			DesignSectionOptions = GetDesignSectionOptions();
		}

		FrameThemeSectionKey = DesignSectionOptions.FirstOrDefault().Key ?? string.Empty;
		return FrameThemeSectionKey;
	}

	private void OnCardThemeChanged()
	{
		if (_pendingBandHighlight)
		{
			_pendingBandHighlight = false;
			ScheduleDesignPreview(BuildBandHighlightRequest());
			return;
		}
		ScheduleDesignPreview(BuildFrameHighlightRequest());
	}

	private void OnBandThemeChanged()
	{
		_pendingBandHighlight = true;
	}

	private HighlightRequest BuildFrameHighlightRequest()
	{
		var target = FrameThemeTab == "per" ? FrameThemeSectionKey : SelectedSectionId;
		if (string.IsNullOrWhiteSpace(target))
		{
			target = DesignSectionOptions.FirstOrDefault().Key ?? string.Empty;
		}
		var normalized = NormalizeHighlightId(target);

		if (string.IsNullOrWhiteSpace(normalized))
		{
			return new HighlightRequest
			{
				ScopeType = "page",
				Style = "wash",
				DurationMs = 320
			};
		}

		return new HighlightRequest
		{
			ScopeType = "section",
			Id = normalized,
			Style = "glow",
			DurationMs = 320
		};
	}

	private HighlightRequest BuildBandHighlightRequest()
	{
		var target = FrameThemeTab == "per" ? FrameThemeSectionKey : SelectedSectionId;
		if (string.IsNullOrWhiteSpace(target))
		{
			target = DesignSectionOptions.FirstOrDefault().Key ?? string.Empty;
		}
		var normalized = NormalizeHighlightId(target);
		var id = string.IsNullOrWhiteSpace(normalized) ? "band" : $"band-{normalized}";
		return new HighlightRequest
		{
			ScopeType = "slot",
			Id = id,
			Style = "outline",
			DurationMs = 320
		};
	}


	private async Task OnCardColorUsed(string color)
	{
		if (string.IsNullOrWhiteSpace(color))
		{
			return;
		}

		if (RecentCardColors.Contains(color, StringComparer.OrdinalIgnoreCase))
		{
			RecentCardColors.RemoveAll(c => string.Equals(c, color, StringComparison.OrdinalIgnoreCase));
		}

		RecentCardColors.Insert(0, color);
		if (RecentCardColors.Count > 8)
		{
			RecentCardColors.RemoveRange(8, RecentCardColors.Count - 8);
		}

		await SaveRecentCardColorsAsync();
	}

	private async Task LoadRecentCardColorsAsync()
	{
		try
		{
			var colors = await JS.InvokeAsync<string[]>("lpCardColors.load");
			RecentCardColors.Clear();
			if (colors is not null)
			{
				foreach (var color in colors.Where(c => !string.IsNullOrWhiteSpace(c)))
				{
					RecentCardColors.Add(color);
				}
			}
			await InvokeAsync(StateHasChanged);
		}
		catch
		{
			return;
		}
	}

	private async Task SaveRecentCardColorsAsync()
	{
		try
		{
			await JS.InvokeVoidAsync("lpCardColors.save", RecentCardColors.ToArray());
		}
		catch
		{
			return;
		}
	}

	private void ResetCardTheme()
	{
		State.Content.FrameDefaultStyle = new FrameStyle();
		EnsureCardThemeDefaults(State.Content.FrameDefaultStyle);
		State.Content.CardThemeStyle = State.Content.FrameDefaultStyle;
		ScheduleDesignPreview();
	}

	private void EnsureFrameDefaultStyle()
	{
		if (State.Content.FrameDefaultStyle is null)
		{
			State.Content.FrameDefaultStyle = State.Content.CardThemeStyle ?? new FrameStyle();
		}
		EnsureCardThemeDefaults(State.Content.FrameDefaultStyle);
		State.Content.CardThemeStyle = State.Content.FrameDefaultStyle;
	}

	private void CleanFrameOverrideData()
	{
		if (State.Content.SectionStyles is null || State.Content.SectionStyles.Count == 0)
		{
			return;
		}

		foreach (var entry in State.Content.SectionStyles.Values)
		{
			if (entry?.FrameStyleOverride is not null)
			{
				entry.FrameStyleOverride = null;
			}
		}
	}

	private static void EnsureCardThemeDefaults(FrameStyle style)
	{
		style.Type = string.IsNullOrWhiteSpace(style.Type) ? "simple" : style.Type;
		style.BackgroundColor ??= "#ffffff";
		style.BackgroundOpacity ??= 100;
		style.BorderColor ??= "#dc2626";
		style.BorderWidth ??= 6;
		style.BorderStyle = string.IsNullOrWhiteSpace(style.BorderStyle) ? "solid" : style.BorderStyle;
		style.BorderRadius ??= 0;
		style.ShadowLevel = string.IsNullOrWhiteSpace(style.ShadowLevel) ? "off" : style.ShadowLevel;
		style.PaddingPreset = string.IsNullOrWhiteSpace(style.PaddingPreset) ? "normal" : style.PaddingPreset;
		style.PaddingX ??= 24;
		style.PaddingY ??= 20;
		style.MaxWidthPx ??= 900;
		style.HeaderBackgroundColor ??= "#dc2626";
		style.HeaderTextColor ??= "#ffffff";
		style.HeaderFontSizePx ??= 30;
		style.HeaderHeightPx ??= 80;
		style.BodyFontSizePx ??= 18;
	}

	private string EditingSectionGroupKey = string.Empty;
	private string EditingSectionGroupName = string.Empty;

	private bool IsEditingSectionGroupName(string? key)
	{
		if (string.IsNullOrWhiteSpace(key))
		{
			return false;
		}

		return string.Equals(EditingSectionGroupKey, key, StringComparison.OrdinalIgnoreCase);
	}

	private void BeginEditSectionGroupName(SectionGroupModel group)
	{
		if (group is null || string.IsNullOrWhiteSpace(group.Key))
		{
			return;
		}

		EditingSectionGroupKey = group.Key;
		EditingSectionGroupName = string.IsNullOrWhiteSpace(group.DisplayName)
			? GetSectionDisplayName(group.Key)
			: group.DisplayName;
	}

	private void CommitEditSectionGroupName(SectionGroupModel group)
	{
		if (group is null || string.IsNullOrWhiteSpace(group.Key))
		{
			return;
		}

		if (!string.Equals(EditingSectionGroupKey, group.Key, StringComparison.OrdinalIgnoreCase))
		{
			return;
		}

		var draft = EditingSectionGroupName?.Trim() ?? string.Empty;
		group.DisplayName = string.IsNullOrWhiteSpace(draft) ? null : draft;
		EditingSectionGroupKey = string.Empty;
		EditingSectionGroupName = string.Empty;
		OnAnyInputAfter();
	}

	private void CancelEditSectionGroupName(SectionGroupModel group)
	{
		if (group is null || string.IsNullOrWhiteSpace(group.Key))
		{
			return;
		}

		if (!string.Equals(EditingSectionGroupKey, group.Key, StringComparison.OrdinalIgnoreCase))
		{
			return;
		}

		EditingSectionGroupKey = string.Empty;
		EditingSectionGroupName = string.Empty;
	}

	private void OnSectionGroupNameKeydown(KeyboardEventArgs e, SectionGroupModel group)
	{
		if (e.Key == "Enter")
		{
			CommitEditSectionGroupName(group);
		}
		else if (e.Key == "Escape")
		{
			CancelEditSectionGroupName(group);
		}
	}

	private void SyncPageBackgroundSetting()
	{
		PageBackgroundSetting = BackgroundSettingMapper.FromPage(State.Content.LpBackground);
	}

	private async Task OnPageBackgroundChanged()
	{
		if (!string.IsNullOrWhiteSpace(PageBackgroundSetting?.Preset?.PresetKey))
		{
			PageBackgroundSetting.SourceType = "preset";
			PageBackgroundSetting.Mode = "preset";
		}
		BackgroundSettingMapper.ApplyToPage(PageBackgroundSetting!, State.Content.LpBackground);
		await NotifyChanged();
		await TriggerHighlightAsync(string.Empty, "background");
	}


	private async Task ApplyBackgroundPreset(BackgroundPresetModel preset)
	{
		var target = State.Content.LpBackground;
		target.Preset ??= new BackgroundPresetSelection();
		target.Preset.PresetKey = preset.Id;
		target.Preset.CssClass = preset.CssClass;
		target.Preset.ColorA = preset.Defaults.BaseColor;
		target.Preset.ColorB = preset.Defaults.AccentColor;
		target.Preset.Opacity = preset.Defaults.Opacity ?? 1;
		target.Preset.Scale = preset.Defaults.Scale ?? 1;

		await NotifyChanged();
		TriggerPageHighlight();
	}

	private void ApplyBulkStyle(IEnumerable<TextItemModel> items, BulkTextStyle style)
	{
		foreach (var item in items)
		{
			item.Bold = style.Bold;
			item.FontSize = style.FontSize;
			if (style.UseColor)
			{
				item.UseColor = true;
				item.Color = string.IsNullOrWhiteSpace(style.Color) ? "#0f172a" : style.Color;
			}
			else
			{
				item.UseColor = false;
				item.Color = null;
			}
		}

		OnAnyInputAfter();
	}

	private void ApplyBulkStyle(IEnumerable<RankingTextItemModel> items, BulkTextStyle style)
	{
		foreach (var item in items)
		{
			item.Bold = style.Bold;
			item.FontSize = style.FontSize;
			if (style.UseColor)
			{
				item.UseColor = true;
				item.Color = string.IsNullOrWhiteSpace(style.Color) ? "#0f172a" : style.Color;
			}
			else
			{
				item.UseColor = false;
				item.Color = null;
			}
		}

		OnAnyInputAfter();
	}

	private sealed class BulkTextStyle
	{
		public bool Bold { get; set; }
		public bool UseColor { get; set; }
		public string? Color { get; set; }
		public int? FontSize { get; set; }
	}

	private sealed class ResponsiveDeviceOption
	{
		public ResponsiveDeviceOption(string key, string label, int width, int height, double dpr)
		{
			Key = key;
			Label = label;
			Width = width;
			Height = height;
			Dpr = dpr;
		}

		public string Key { get; }
		public string Label { get; }
		public int Width { get; }
		public int Height { get; }
		public double Dpr { get; }
	}

	private async Task SetPreviewMode(bool isMobile)
	{
		HasPreviewModeSelection = true;
		IsResponsivePreview = false;
		SelectedResponsiveDevice = string.Empty;
		State.PreviewIsMobile = isMobile;
		await JS.InvokeVoidAsync("lpSplit.setMode", "lpEditorRoot", "previewPane", isMobile);
		if (isMobile)
		{
			UseViewportSizing = true;
			ResponsiveWidth = SpPreviewWidth;
			ResponsiveHeight = SpPreviewHeight;
			ResponsiveDpr = 1;
			await ApplyResponsiveViewportAsync();
		}
		else
		{
			UseViewportSizing = false;
			await JS.InvokeVoidAsync("lpPreview.resetResponsiveViewport", "previewFrame");
		}
	}

	private async Task OnResponsiveDeviceChanged()
	{
		if (string.IsNullOrWhiteSpace(SelectedResponsiveDevice))
		{
			IsResponsivePreview = false;
			UseViewportSizing = false;
			await JS.InvokeVoidAsync("lpPreview.resetResponsiveViewport", "previewFrame");
			return;
		}

		var device = ResponsiveDevices.FirstOrDefault(d => d.Key == SelectedResponsiveDevice);
		if (device is null)
		{
			return;
		}

		ResponsiveWidth = device.Width;
		ResponsiveHeight = device.Height;
		ResponsiveDpr = device.Dpr;
		HasPreviewModeSelection = true;
		IsResponsivePreview = true;
		UseViewportSizing = true;
		State.PreviewIsMobile = ResponsiveWidth < 600;
		await JS.InvokeVoidAsync("lpSplit.setPreviewWidth", "lpEditorRoot", "previewPane", ResponsiveWidth + 80);
		await ApplyResponsiveViewportAsync();
		await InvokeAsync(StateHasChanged);
	}

	private async Task OnResponsiveDprChanged()
	{
		if (!IsResponsivePreview)
		{
			return;
		}

		await ApplyResponsiveViewportAsync();
		await InvokeAsync(StateHasChanged);
	}

	private string GetPreviewFrameStyle()
	{
		if (IsResponsivePreview)
		{
			return $"width: {EffectiveResponsiveWidth}px; height: {EffectiveResponsiveHeight}px;";
		}

		if (State.PreviewIsMobile)
		{
			var (width, height) = GetEffectiveSize(SpPreviewWidth, SpPreviewHeight);
			return $"width: {width}px; height: {height}px;";
		}

		return "width: 100%; height: 100%;";
	}

	private int EffectiveResponsiveWidth => GetEffectiveSize(ResponsiveWidth, ResponsiveHeight).width;
	private int EffectiveResponsiveHeight => GetEffectiveSize(ResponsiveWidth, ResponsiveHeight).height;

	private (int width, int height) GetEffectiveSize(int width, int height)
	{
		return IsLandscape ? (height, width) : (width, height);
	}

	private async Task ApplyResponsiveViewportAsync()
	{
		if (!UseViewportSizing)
		{
			return;
		}

		var (width, height) = GetEffectiveSize(ResponsiveWidth, ResponsiveHeight);
		await JS.InvokeVoidAsync("lpPreview.setResponsiveViewport", "previewFrameWrapper", "previewFrame", width, height, ResponsiveDpr);
	}

	private async Task ToggleOrientation()
	{
		IsLandscape = !IsLandscape;
		if (UseViewportSizing)
		{
			await ApplyResponsiveViewportAsync();
		}

		await InvokeAsync(StateHasChanged);
	}

	private static int GetMaxWidth(string path)
	{
		if (path.EndsWith("logo.png", StringComparison.OrdinalIgnoreCase))
		{
			return 300;
		}

		if (path.EndsWith("mv.png", StringComparison.OrdinalIgnoreCase))
		{
			return 1600;
		}

		if (path.EndsWith("mv_sp.png", StringComparison.OrdinalIgnoreCase))
		{
			return 900;
		}

		if (path.Contains("conditions", StringComparison.OrdinalIgnoreCase))
		{
			return 1200;
		}

		if (path.Contains("banner", StringComparison.OrdinalIgnoreCase))
		{
			return 1200;
		}

		return 1200;
	}

	private static bool IsValidUrl(string? url)
	{
		if (string.IsNullOrWhiteSpace(url))
		{
			return true;
		}

		return Uri.TryCreate(url, UriKind.Absolute, out var uri)
			   && (uri.Scheme == Uri.UriSchemeHttp || uri.Scheme == Uri.UriSchemeHttps);
	}

	private async Task OnRankingLeftImageSelected(InputFileChangeEventArgs e)
	{
		await OnRankingDecorImageSelected(e, State.Content.Sections.Ranking.LeftTopImage);
	}

	private async Task OnRankingRightImageSelected(InputFileChangeEventArgs e)
	{
		await OnRankingDecorImageSelected(e, State.Content.Sections.Ranking.RightTopImage);
	}

	private async Task OnRankingDecorImageSelected(InputFileChangeEventArgs e, RankingDecorImageModel target)
	{
		State.Error.Clear();
		try
		{
			var file = e.File;
			if (file is null)
			{
				return;
			}

			var fileName = Path.GetFileName(file.Name);
			if (string.IsNullOrWhiteSpace(fileName))
			{
				return;
			}

			using var ms = new MemoryStream();
			await file.OpenReadStream(long.MaxValue).CopyToAsync(ms);
			var bytes = ms.ToArray();
			var path = $"images/{fileName}";
			await SaveCustomSectionImageAsync(path, bytes);
			target.Src = path;
			await UpdatePreviewAsync();
		}
		catch (Exception ex)
		{
			State.Error.SetError("画像アップロードに失敗", ex.Message);
		}
	}
}
